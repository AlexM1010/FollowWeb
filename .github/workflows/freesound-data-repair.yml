# Freesound Data Repair Pipeline
#
# Automated pipeline that detects and repairs checkpoint inconsistencies.
# This workflow is part of the three-pipeline architecture:
# 1. Collection Pipeline: Collects data only
# 2. Repair Pipeline (this workflow): Validates and repairs data integrity issues
# 3. Validation & Visualization Pipeline: Generates visualizations from validated data
# 4. Backup Pipeline: Creates and manages backups
#
# Architecture:
# - Triggered automatically after nightly collection completes (continuation)
# - Inherits checkpoint from collection pipeline via cache
# - Can be triggered manually when data issues are detected
# - Restores checkpoint from cache or repository
# - Runs validation checks
# - Applies repairs if validation fails (fetches missing data from API)
# - Re-validates after repairs
# - Saves repaired checkpoint back to cache and repository
#
# Repair Operations:
# - Missing node metadata: Fetches from Freesound API (up to 50 requests)
# - Orphaned metadata: Rebuilds graph nodes from metadata cache
# - Missing pagination state: Adds default pagination state
# - Edge count mismatches: Updates checkpoint metadata
# - Corrupted checkpoint files: Attempts recovery
#
# Required Secrets:
# - FREESOUND_API_KEY: For fetching missing metadata from Freesound API
# - BACKUP_PAT: For uploading repaired checkpoints to backup repository
#
# Features:
# - Automatic trigger after nightly collection (inherits data)
# - Manual trigger with workflow_dispatch
# - Comprehensive validation and repair with API fetching
# - Request limit (50) to prevent excessive API usage
# - Detailed reporting of repairs performed
# - Saves repaired checkpoint for downstream workflows

name: Freesound Data Repair

on:
  workflow_run:
    workflows: ["Freesound Nightly Collection"]
    types: [completed]
    branches: [main]
  
  workflow_dispatch:
    # Allow manual triggering for ad-hoc repairs
    inputs:
      checkpoint_source:
        description: 'Checkpoint source: cache (from last run) or repo (from backup)'
        required: false
        default: 'repo'
        type: choice
        options:
          - cache
          - repo

# Prevent workflow collisions
concurrency:
  group: freesound-repair
  cancel-in-progress: false

permissions:
  contents: read
  issues: write

jobs:
  repair-checkpoint:
    name: Validate and Repair Checkpoint
    runs-on: ubuntu-latest
    timeout-minutes: 60
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        token: ${{ secrets.GITHUB_TOKEN }}
    
    - name: Configure Git
      run: |
        git config user.name "GitHub Actions Bot"
        git config user.email "actions@github.com"
    
    - name: Set up Python 3.11
      uses: actions/setup-python@v5
      with:
        python-version: '3.11'
        cache: 'pip'
        cache-dependency-path: 'FollowWeb/requirements.txt'
    
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip setuptools wheel
        pip install -r FollowWeb/requirements.txt
        pip install -e FollowWeb/
    
    - name: Determine checkpoint source
      id: source
      run: |
        if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
          echo "source=${{ github.event.inputs.checkpoint_source }}" >> "$GITHUB_OUTPUT"
        else
          # For workflow_run trigger, try cache first
          echo "source=cache" >> "$GITHUB_OUTPUT"
        fi
        
        {
          echo "## ðŸ”§ Data Repair Pipeline"
          echo ""
          echo "**Trigger:** \`${{ github.event_name }}\`"
          echo ""
        } >> "$GITHUB_STEP_SUMMARY"
    
    - name: Restore checkpoint from cache
      if: steps.source.outputs.source == 'cache'
      id: cache_restore
      uses: actions/cache/restore@v3
      with:
        path: data/freesound_library
        key: checkpoint-${{ github.event.workflow_run.id || github.run_id }}
        restore-keys: |
          checkpoint-
    
    - name: Download checkpoint from repository
      if: steps.source.outputs.source == 'repo' || steps.cache_restore.outputs.cache-hit != 'true'
      env:
        BACKUP_PAT: ${{ secrets.BACKUP_PAT }}
      run: |
        {
          echo "### ðŸ“¥ Download Checkpoint"
          echo ""
        } >> "$GITHUB_STEP_SUMMARY"
        
        if [ -z "$BACKUP_PAT" ]; then
          echo "::error::BACKUP_PAT not configured"
          echo "- Status: âŒ Cannot download checkpoint" >> "$GITHUB_STEP_SUMMARY"
          exit 1
        fi
        
        REPO_OWNER="${{ github.repository_owner }}"
        BACKUP_REPO="${REPO_OWNER}/freesound-backup"
        
        # Get latest checkpoint from v-checkpoint release
        ASSETS_JSON=$(curl -s -H "Authorization: token $BACKUP_PAT" \
          "https://api.github.com/repos/${BACKUP_REPO}/releases/tags/v-checkpoint")
        
        if echo "$ASSETS_JSON" | grep -q "Not Found"; then
          echo "::error::Release v-checkpoint not found"
          echo "- Status: âŒ No backup available" >> "$GITHUB_STEP_SUMMARY"
          exit 1
        fi
        
        LATEST_ASSET=$(echo "$ASSETS_JSON" | jq -r '.assets | sort_by(.created_at) | reverse | .[0]')
        
        if [ "$LATEST_ASSET" = "null" ] || [ -z "$LATEST_ASSET" ]; then
          echo "::error::No checkpoint backups found"
          echo "- Status: âŒ No backup available" >> "$GITHUB_STEP_SUMMARY"
          exit 1
        fi
        
        ASSET_NAME=$(echo "$LATEST_ASSET" | jq -r '.name')
        ASSET_URL=$(echo "$LATEST_ASSET" | jq -r '.url')
        ASSET_SIZE=$(echo "$LATEST_ASSET" | jq -r '.size')
        
        echo "Downloading: $ASSET_NAME"
        curl -L -H "Authorization: token $BACKUP_PAT" \
          -H "Accept: application/octet-stream" \
          "$ASSET_URL" -o checkpoint_backup.tar.gz
        
        # Validate tar archive before extraction
        echo "Validating checkpoint archive..."
        if ! tar -tzf checkpoint_backup.tar.gz > /dev/null 2>&1; then
          echo "::error::Checkpoint archive is corrupted"
          exit 1
        fi
        
        # Check if archive is empty
        file_count=$(tar -tzf checkpoint_backup.tar.gz | wc -l)
        if [ "$file_count" -eq 0 ]; then
          echo "::error::Checkpoint archive is empty"
          exit 1
        fi
        
        echo "Archive validated: $file_count files"
        
        mkdir -p data/freesound_library
        tar -xzf checkpoint_backup.tar.gz -C data/
        
        # Verify extraction succeeded
        if [ ! -d "data/freesound_library" ]; then
          echo "::error::Checkpoint extraction failed - directory not created"
          exit 1
        fi
        
        rm -f checkpoint_backup.tar.gz
        
        {
          echo "- Source: \`$ASSET_NAME\`"
          echo "- Size: \`$(numfmt --to=iec-i --suffix=B "$ASSET_SIZE")\`"
          echo ""
        } >> "$GITHUB_STEP_SUMMARY"
    
    - name: Run validation checks
      id: validation
      run: |
        {
          echo "### ðŸ” Validation Checks"
          echo ""
        } >> "$GITHUB_STEP_SUMMARY"
        
        # Run validation script and capture exit code (use PIPESTATUS to get python exit code, not tee)
        set +e  # Disable exit on error temporarily
        python scripts/validation/validate_checkpoint.py data/freesound_library 2>&1 | tee validation_output.log
        VALIDATION_EXIT_CODE=${PIPESTATUS[0]}
        set -e  # Re-enable exit on error
        
        if [ "$VALIDATION_EXIT_CODE" -eq 0 ]; then
          echo "validation_passed=true" >> "$GITHUB_OUTPUT"
          echo "- Status: âœ… All checks passed" >> "$GITHUB_STEP_SUMMARY"
        else
          echo "validation_passed=false" >> "$GITHUB_OUTPUT"
          echo "- Status: âŒ Validation failed" >> "$GITHUB_STEP_SUMMARY"
        fi
        echo "" >> "$GITHUB_STEP_SUMMARY"
    
    - name: Run repair operations
      if: steps.validation.outputs.validation_passed == 'false'
      id: repair
      env:
        FREESOUND_API_KEY: ${{ secrets.FREESOUND_API_KEY }}
      run: |
        {
          echo "### ðŸ”§ Repair Operations"
          echo ""
        } >> "$GITHUB_STEP_SUMMARY"
        
        # Run repair script with API key and request limit
        # Limit to 10 requests to avoid excessive API usage during repairs
        if python scripts/validation/repair_checkpoint.py \
          --checkpoint-dir data/freesound_library \
          --api-key "$FREESOUND_API_KEY" \
          --max-requests 10 \
          2>&1 | tee repair_output.log; then
          echo "repair_success=true" >> "$GITHUB_OUTPUT"
          echo "- Status: âœ… Repairs completed" >> "$GITHUB_STEP_SUMMARY"
        else
          echo "repair_success=false" >> "$GITHUB_OUTPUT"
          echo "- Status: âŒ Repairs failed" >> "$GITHUB_STEP_SUMMARY"
          exit 1
        fi
        echo "" >> "$GITHUB_STEP_SUMMARY"
    
    - name: Re-validate after repairs
      if: steps.repair.outputs.repair_success == 'true'
      id: revalidation
      run: |
        {
          echo "### ðŸ” Re-validation After Repairs"
          echo ""
        } >> "$GITHUB_STEP_SUMMARY"
        
        # Run validation again
        if python scripts/validation/validate_checkpoint.py data/freesound_library; then
          echo "revalidation_passed=true" >> "$GITHUB_OUTPUT"
          echo "- Status: âœ… All checks passed" >> "$GITHUB_STEP_SUMMARY"
        else
          echo "revalidation_passed=false" >> "$GITHUB_OUTPUT"
          {
            echo "- Status: âŒ Validation still failing"
            echo ""
            echo "**Warning:** Repairs did not resolve all issues. Manual intervention may be required."
          } >> "$GITHUB_STEP_SUMMARY"
          exit 1
        fi
        echo "" >> "$GITHUB_STEP_SUMMARY"
    
    # CRITICAL: Upload to permanent storage FIRST (before cache)
    # Cache is ephemeral (7-day retention) and should only be a fallback
    - name: Upload checkpoint to repository (PRIORITY - repaired or validated)
      id: upload_checkpoint
      if: always() && (steps.validation.outputs.validation_passed == 'true' || (steps.repair.outputs.repair_success == 'true' && steps.revalidation.outputs.revalidation_passed == 'true'))
      env:
        BACKUP_PAT: ${{ secrets.BACKUP_PAT }}
      run: |
        {
          echo "### ðŸ“¤ Upload Checkpoint"
          echo ""
        } >> "$GITHUB_STEP_SUMMARY"
        
        if [ -z "$BACKUP_PAT" ]; then
          echo "::warning::BACKUP_PAT not configured, skipping upload"
          echo "- Status: âš ï¸ Upload skipped" >> "$GITHUB_STEP_SUMMARY"
          exit 0
        fi
        
        # Determine backup type
        if [ "${{ steps.repair.outputs.repair_success }}" = "true" ]; then
          backup_type="repaired"
        else
          backup_type="validated"
        fi
        
        # Create backup archive
        backup_filename="checkpoint_${backup_type}_${{ github.run_id }}.tar.gz"
        tar -czf "$backup_filename" -C data freesound_library/
        
        backup_size=$(stat -f%z "$backup_filename" 2>/dev/null || stat -c%s "$backup_filename")
        
        REPO_OWNER="${{ github.repository_owner }}"
        BACKUP_REPO="${REPO_OWNER}/freesound-backup"
        
        # Get v-checkpoint release
        RELEASE_JSON=$(curl -s -H "Authorization: token $BACKUP_PAT" \
          "https://api.github.com/repos/${BACKUP_REPO}/releases/tags/v-checkpoint")
        
        RELEASE_ID=$(echo "$RELEASE_JSON" | jq -r '.id')
        
        if [ "$RELEASE_ID" = "null" ] || [ -z "$RELEASE_ID" ]; then
          echo "::error::Release v-checkpoint not found"
          echo "- Status: âŒ Upload failed" >> "$GITHUB_STEP_SUMMARY"
          rm -f "$backup_filename"
          exit 1
        fi
        
        # Upload asset
        UPLOAD_URL="https://uploads.github.com/repos/${BACKUP_REPO}/releases/${RELEASE_ID}/assets?name=${backup_filename}"
        
        UPLOAD_RESPONSE=$(curl -s -X POST \
          -H "Authorization: token $BACKUP_PAT" \
          -H "Content-Type: application/gzip" \
          --data-binary "@${backup_filename}" \
          "$UPLOAD_URL")
        
        ASSET_ID=$(echo "$UPLOAD_RESPONSE" | jq -r '.id')
        
        if [ "$ASSET_ID" = "null" ] || [ -z "$ASSET_ID" ]; then
          echo "::error::Failed to upload repaired checkpoint"
          echo "- Status: âŒ Upload failed" >> "$GITHUB_STEP_SUMMARY"
          rm -f "$backup_filename"
          exit 1
        fi
        
        {
          echo "- Backup: \`$backup_filename\`"
          echo "- Size: \`$(numfmt --to=iec-i --suffix=B "$backup_size")\`"
          echo "- Status: âœ… Uploaded successfully"
          echo ""
        } >> "$GITHUB_STEP_SUMMARY"
        
        echo "upload_success=true" >> "$GITHUB_OUTPUT"
        
        rm -f "$backup_filename"
    
    # Debug: List checkpoint files before caching
    - name: Debug - List checkpoint files
      if: always() && (steps.validation.outputs.validation_passed == 'true' || (steps.repair.outputs.repair_success == 'true' && steps.revalidation.outputs.revalidation_passed == 'true'))
      run: |
        echo "Listing checkpoint directory contents:"
        ls -laR data/freesound_library/ || echo "Directory not found"
        echo ""
        echo "File sizes:"
        du -h data/freesound_library/* || echo "No files found"
        echo ""
        echo "Total directory size:"
        du -sh data/freesound_library/ || echo "Directory not found"
    
    # Save to cache as SECONDARY backup (after permanent storage)
    # Cache has 7-day retention and should only be used as fallback
    - name: Save checkpoint to cache (SECONDARY backup - for downstream workflows)
      if: always() && (steps.validation.outputs.validation_passed == 'true' || (steps.repair.outputs.repair_success == 'true' && steps.revalidation.outputs.revalidation_passed == 'true'))
      id: cache_save
      uses: actions/cache/save@v3
      with:
        path: data/freesound_library
        key: checkpoint-repaired-${{ github.run_id }}
    
    - name: Verify cache integrity and warn if permanent storage failed
      if: always() && (steps.validation.outputs.validation_passed == 'true' || (steps.repair.outputs.repair_success == 'true' && steps.revalidation.outputs.revalidation_passed == 'true'))
      run: |
        {
          echo "### ðŸ” Cache Verification"
          echo ""
        } >> "$GITHUB_STEP_SUMMARY"
        
        # Verify checkpoint files exist
        CHECKPOINT_DIR="data/freesound_library"
        
        if [ ! -d "$CHECKPOINT_DIR" ]; then
          echo "::error::Checkpoint directory not found"
          echo "- âŒ Directory not found" >> "$GITHUB_STEP_SUMMARY"
          exit 1
        fi
        
        # Check all three required files
        missing_files=0
        
        if [ ! -f "$CHECKPOINT_DIR/graph_topology.gpickle" ]; then
          echo "::error::Missing graph_topology.gpickle"
          echo "- âŒ Missing: graph_topology.gpickle" >> "$GITHUB_STEP_SUMMARY"
          missing_files=$((missing_files + 1))
        else
          graph_size=$(stat -f%z "$CHECKPOINT_DIR/graph_topology.gpickle" 2>/dev/null || stat -c%s "$CHECKPOINT_DIR/graph_topology.gpickle")
          echo "- âœ… graph_topology.gpickle ($(numfmt --to=iec-i --suffix=B "$graph_size"))" >> "$GITHUB_STEP_SUMMARY"
        fi
        
        if [ ! -f "$CHECKPOINT_DIR/metadata_cache.db" ]; then
          echo "::error::Missing metadata_cache.db"
          echo "- âŒ Missing: metadata_cache.db" >> "$GITHUB_STEP_SUMMARY"
          missing_files=$((missing_files + 1))
        else
          db_size=$(stat -f%z "$CHECKPOINT_DIR/metadata_cache.db" 2>/dev/null || stat -c%s "$CHECKPOINT_DIR/metadata_cache.db")
          echo "- âœ… metadata_cache.db ($(numfmt --to=iec-i --suffix=B "$db_size"))" >> "$GITHUB_STEP_SUMMARY"
        fi
        
        if [ ! -f "$CHECKPOINT_DIR/checkpoint_metadata.json" ]; then
          echo "::error::Missing checkpoint_metadata.json"
          echo "- âŒ Missing: checkpoint_metadata.json" >> "$GITHUB_STEP_SUMMARY"
          missing_files=$((missing_files + 1))
        else
          meta_size=$(stat -f%z "$CHECKPOINT_DIR/checkpoint_metadata.json" 2>/dev/null || stat -c%s "$CHECKPOINT_DIR/checkpoint_metadata.json")
          echo "- âœ… checkpoint_metadata.json ($(numfmt --to=iec-i --suffix=B "$meta_size"))" >> "$GITHUB_STEP_SUMMARY"
        fi
        
        if [ "$missing_files" -gt 0 ]; then
          echo "::error::Cache save verification failed - $missing_files files missing"
          {
            echo ""
            echo "âš ï¸ **WARNING**: Cache was saved but is incomplete!"
            echo "âš ï¸ **Downstream workflows may fail!**"
            echo ""
          } >> "$GITHUB_STEP_SUMMARY"
          exit 1
        fi
        
        # Check if permanent storage upload succeeded
        permanent_uploaded="${{ steps.upload_checkpoint.outputs.upload_success }}"
        
        if [ "$permanent_uploaded" != "true" ]; then
          {
            echo ""
            echo "## âš ï¸ CRITICAL WARNING: Data Persistence Risk"
            echo ""
            echo "**Permanent storage upload FAILED!**"
            echo ""
            echo "Checkpoint was saved to cache only, which has **7-day retention**."
            echo "Data may be lost after 7 days if not backed up to permanent storage."
            echo ""
            echo "### Immediate Actions Required:"
            echo "1. Investigate permanent storage upload failure"
            echo "2. Manually download checkpoint from cache"
            echo "3. Upload to permanent storage manually"
            echo "4. Fix BACKUP_PAT or repository permissions"
            echo ""
            echo "### Cache Details:"
            echo "- Cache Key: \`checkpoint-repaired-${{ github.run_id }}\`"
            echo "- Retention: 7 days"
            echo "- Expires: $(date -u -d '7 days' +%Y-%m-%d 2>/dev/null || date -u -v+7d +%Y-%m-%d 2>/dev/null)"
            echo ""
          } >> "$GITHUB_STEP_SUMMARY"
          
          echo "::warning::Checkpoint saved to cache only - 7-day retention risk!"
        else
          {
            echo ""
            echo "âœ… All checkpoint files verified"
            echo "âœ… Cache key: \`checkpoint-repaired-${{ github.run_id }}\`"
            echo ""
            echo "### âœ… Data Persistence Status"
            echo "- Primary: âœ… Permanent storage (safe)"
            echo "- Secondary: âœ… Cache (7-day fallback)"
            echo ""
          } >> "$GITHUB_STEP_SUMMARY"
        fi
    
    - name: Generate repair summary
      if: always()
      run: |
        {
          echo "---"
          echo ""
          echo "## ðŸ“Š Repair Summary"
          echo ""
        } >> "$GITHUB_STEP_SUMMARY"
        
        if [ "${{ steps.validation.outputs.validation_passed }}" = "true" ]; then
          {
            echo "### âœ… No Repairs Needed"
            echo ""
            echo "All validation checks passed. Checkpoint is healthy."
          } >> "$GITHUB_STEP_SUMMARY"
        elif [ "${{ steps.repair.outputs.repair_success }}" = "true" ] && [ "${{ steps.revalidation.outputs.revalidation_passed }}" = "true" ]; then
          {
            echo "### âœ… Repairs Successful"
            echo ""
            echo "Checkpoint issues were detected and successfully repaired."
            echo ""
            echo "**Actions Taken:**"
            echo "- Validation identified issues"
            echo "- Repair operations applied"
            echo "- Re-validation confirmed fixes"
            echo "- Repaired checkpoint uploaded to backup repository"
          } >> "$GITHUB_STEP_SUMMARY"
        elif [ "${{ steps.repair.outputs.repair_success }}" = "false" ]; then
          {
            echo "### âŒ Repairs Failed"
            echo ""
            echo "Repair operations failed. Manual intervention required."
          } >> "$GITHUB_STEP_SUMMARY"
        elif [ "${{ steps.revalidation.outputs.revalidation_passed }}" = "false" ]; then
          {
            echo "### âš ï¸ Partial Repair"
            echo ""
            echo "Repairs were applied but validation still fails. Additional investigation needed."
          } >> "$GITHUB_STEP_SUMMARY"
        else
          {
            echo "### âŒ Repair Pipeline Error"
            echo ""
            echo "An unexpected error occurred during the repair process."
          } >> "$GITHUB_STEP_SUMMARY"
        fi
        
        {
          echo ""
          echo "### ðŸ“‹ Execution Details"
          echo ""
          echo "| Detail | Value |"
          echo "|--------|-------|"
          echo "| **Workflow Run** | [#${{ github.run_number }}](https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}) |"
          echo "| **Trigger** | \`${{ github.event_name }}\` |"
        } >> "$GITHUB_STEP_SUMMARY"
        if [ "${{ github.event_name }}" = "workflow_run" ]; then
          echo "| **Source Workflow** | [Run #${{ github.event.workflow_run.run_number }}](https://github.com/${{ github.repository }}/actions/runs/${{ github.event.workflow_run.id }}) |" >> "$GITHUB_STEP_SUMMARY"
        fi
        {
          echo "| **Checkpoint Source** | \`${{ steps.source.outputs.source }}\` |"
          echo ""
        } >> "$GITHUB_STEP_SUMMARY"
    
    - name: Upload repair logs
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: repair-logs-${{ github.run_id }}
        path: |
          *.log
          validation_output.log
          repair_output.log
        retention-days: 30
        if-no-files-found: ignore
    
    - name: Create issue on failure
      if: failure()
      continue-on-error: true
      uses: actions/github-script@v7
      with:
        script: |
          const issue_body = `## ðŸ”§ Repair Pipeline Failed
          
          The data repair pipeline encountered an error and could not complete successfully.
          
          ### Details
          - **Workflow Run:** [#${{ github.run_number }}](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})
          - **Trigger:** \`${{ github.event_name }}\`
          - **Branch:** \`${{ github.ref_name }}\`
          - **Timestamp:** ${new Date().toISOString()}
          
          ### Possible Causes
          - Checkpoint files corrupted beyond repair
          - Database connection issues
          - Insufficient disk space
          - Network connectivity problems
          
          ### Next Steps
          1. Review the [workflow logs](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})
          2. Download repair logs from artifacts
          3. Check checkpoint integrity manually
          4. Consider restoring from backup if needed
          
          ### Artifacts
          - Repair logs available in workflow artifacts (30-day retention)
          
          ---
          *This issue was automatically created by the repair pipeline.*`;
          
          github.rest.issues.create({
            owner: context.repo.owner,
            repo: context.repo.repo,
            title: `ðŸ”§ Repair Pipeline Failed - Run #${{ github.run_number }}`,
            body: issue_body,
            labels: ['automated', 'repair-failure', 'needs-investigation']
          });
