# Freesound Data Repair Pipeline
#
# Automated pipeline that detects and repairs checkpoint inconsistencies.
# This workflow is part of the three-pipeline architecture:
# 1. Collection Pipeline: Collects data only
# 2. Repair Pipeline (this workflow): Validates and repairs data integrity issues
# 3. Validation & Visualization Pipeline: Generates visualizations from validated data
# 4. Backup Pipeline: Creates and manages backups
#
# Architecture:
# - Triggered automatically after nightly collection completes (continuation)
# - Inherits checkpoint from collection pipeline via cache
# - Can be triggered manually when data issues are detected
# - Restores checkpoint from cache or repository
# - Runs validation checks
# - Applies repairs if validation fails (fetches missing data from API)
# - Re-validates after repairs
# - Saves repaired checkpoint back to cache and repository
#
# Repair Operations:
# - Missing node metadata: Fetches from Freesound API (up to 50 requests)
# - Orphaned metadata: Rebuilds graph nodes from metadata cache
# - Missing pagination state: Adds default pagination state
# - Edge count mismatches: Updates checkpoint metadata
# - Corrupted checkpoint files: Attempts recovery
#
# Required Secrets:
# - FREESOUND_API_KEY: For fetching missing metadata from Freesound API
# - BACKUP_PAT: For uploading repaired checkpoints to backup repository
#
# Features:
# - Automatic trigger after nightly collection (inherits data)
# - Manual trigger with workflow_dispatch
# - Comprehensive validation and repair with API fetching
# - Request limit (50) to prevent excessive API usage
# - Detailed reporting of repairs performed
# - Saves repaired checkpoint for downstream workflows

name: Freesound Data Repair

on:
  workflow_run:
    workflows: ["Freesound Nightly Collection"]
    types: [completed]
    branches: [main]
  
  workflow_dispatch:
    # Allow manual triggering for ad-hoc repairs
    inputs:
      checkpoint_source:
        description: 'Checkpoint source: cache (from last run) or repo (from backup)'
        required: false
        default: 'repo'
        type: choice
        options:
          - cache
          - repo
      max_requests:
        description: 'Max API requests for repair (0 = validation only, no repair)'
        required: false
        default: '50'
        type: string
      skip_repair:
        description: 'Skip repair and only validate'
        required: false
        default: false
        type: boolean

# Prevent workflow collisions
concurrency:
  group: freesound-repair
  cancel-in-progress: false

permissions:
  contents: read
  issues: write

jobs:
  check-collection-status:
    name: Check Collection Status
    runs-on: ubuntu-latest
    timeout-minutes: 5
    outputs:
      should_run: ${{ steps.check.outputs.should_run }}
      skip_reason: ${{ steps.check.outputs.skip_reason }}
    
    steps:
    - name: Check if collection ran successfully
      id: check
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      run: |
        # For manual triggers, always run
        if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
          echo "should_run=true" >> "$GITHUB_OUTPUT"
          echo "skip_reason=" >> "$GITHUB_OUTPUT"
          echo "âœ… Manual trigger - proceeding with repair"
          exit 0
        fi
        
        # For workflow_run triggers, check if collection actually ran
        COLLECTION_RUN_ID="${{ github.event.workflow_run.id }}"
        
        # Check if the freesound-collection job actually ran
        JOBS=$(curl -s -H "Authorization: token $GITHUB_TOKEN" \
          -H "Accept: application/vnd.github.v3+json" \
          "https://api.github.com/repos/${{ github.repository }}/actions/runs/$COLLECTION_RUN_ID/jobs")
        
        # Check if freesound-collection job exists and completed successfully
        COLLECTION_JOB=$(echo "$JOBS" | jq -r '.jobs[] | select(.name == "Freesound Data Collection")')
        
        if [ -z "$COLLECTION_JOB" ] || [ "$COLLECTION_JOB" = "null" ]; then
          echo "âš ï¸ Collection job was skipped (likely due to CI check failure)"
          echo "should_run=false" >> "$GITHUB_OUTPUT"
          echo "skip_reason=Collection job was skipped - no data to repair" >> "$GITHUB_OUTPUT"
          
          {
            echo "## âš ï¸ Repair Skipped"
            echo ""
            echo "The collection job was skipped (likely due to CI check failure)."
            echo "No data collection occurred, so repair is not needed."
          } >> "$GITHUB_STEP_SUMMARY"
          exit 0
        fi
        
        JOB_CONCLUSION=$(echo "$COLLECTION_JOB" | jq -r '.conclusion')
        
        if [ "$JOB_CONCLUSION" = "skipped" ]; then
          echo "âš ï¸ Collection job was skipped"
          echo "should_run=false" >> "$GITHUB_OUTPUT"
          echo "skip_reason=Collection job was skipped" >> "$GITHUB_OUTPUT"
          
          {
            echo "## âš ï¸ Repair Skipped"
            echo ""
            echo "The collection job was skipped."
            echo "No data collection occurred, so repair is not needed."
          } >> "$GITHUB_STEP_SUMMARY"
        else
          echo "âœ… Collection job ran - proceeding with repair"
          echo "should_run=true" >> "$GITHUB_OUTPUT"
          echo "skip_reason=" >> "$GITHUB_OUTPUT"
          
          {
            echo "## âœ… Collection Completed"
            echo ""
            echo "Collection job completed with status: $JOB_CONCLUSION"
            echo "Proceeding with repair and validation..."
          } >> "$GITHUB_STEP_SUMMARY"
        fi

  repair-checkpoint:
    name: Validate and Repair Checkpoint
    runs-on: ubuntu-latest
    timeout-minutes: 60
    needs: check-collection-status
    if: needs.check-collection-status.outputs.should_run == 'true'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        token: ${{ secrets.GITHUB_TOKEN }}
    
    - name: Configure Git
      run: |
        git config user.name "GitHub Actions Bot"
        git config user.email "actions@github.com"
    
    - name: Set up Python 3.11
      uses: actions/setup-python@v5
      with:
        python-version: '3.11'
        cache: 'pip'
        cache-dependency-path: 'FollowWeb/requirements.txt'
    
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip setuptools wheel
        pip install -r FollowWeb/requirements.txt
        pip install -e FollowWeb/
    
    - name: Determine checkpoint source and mode
      id: source
      run: |
        if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
          {
            echo "source=${{ github.event.inputs.checkpoint_source }}"
            echo "skip_repair=${{ github.event.inputs.skip_repair }}"
            echo "manual_max_requests=${{ github.event.inputs.max_requests }}"
          } >> "$GITHUB_OUTPUT"
        else
          # For workflow_run trigger, try cache first
          {
            echo "source=cache"
            echo "skip_repair=false"
            echo "manual_max_requests="
          } >> "$GITHUB_OUTPUT"
        fi
        
        {
          echo "## ðŸ”§ Data Repair Pipeline"
          echo ""
          echo "**Trigger:** \`${{ github.event_name }}\`"
          
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            MODE="$([ "${{ github.event.inputs.skip_repair }}" = "true" ] && echo "Validation Only" || echo "Validation + Repair")"
            echo "**Mode:** \`$MODE\`"
            echo "**Checkpoint Source:** \`${{ github.event.inputs.checkpoint_source }}\`"
            if [ "${{ github.event.inputs.skip_repair }}" != "true" ]; then
              echo "**Max Requests:** \`${{ github.event.inputs.max_requests }}\`"
            fi
          fi
          echo ""
        } >> "$GITHUB_STEP_SUMMARY"
    
    - name: Restore checkpoint from cache
      if: steps.source.outputs.source == 'cache'
      id: cache_restore
      uses: actions/cache/restore@v3
      with:
        path: data/freesound_library
        key: checkpoint-${{ github.event.workflow_run.id || github.run_id }}
        restore-keys: |
          checkpoint-
    
    - name: Restore checkpoint from backup repository
      if: steps.source.outputs.source == 'repo'
      id: repo_restore
      env:
        BACKUP_PAT: ${{ secrets.BACKUP_PAT }}
      run: |
        {
          echo "### ðŸ“¥ Restoring from Backup Repository"
          echo ""
        } >> "$GITHUB_STEP_SUMMARY"
        
        REPO_OWNER="${{ github.repository_owner }}"
        BACKUP_REPO="${REPO_OWNER}/freesound-backup"
        
        # Get latest checkpoint from v-checkpoint release
        echo "Fetching latest checkpoint from backup repository..."
        RELEASE_JSON=$(curl -s -H "Authorization: token $BACKUP_PAT" \
          "https://api.github.com/repos/${BACKUP_REPO}/releases/tags/v-checkpoint")
        
        if echo "$RELEASE_JSON" | grep -q "Not Found"; then
          echo "::error::No checkpoint release found in backup repository"
          {
            echo "- âŒ No checkpoint release found"
            echo ""
            echo "**Action:** Run collection pipeline first to create initial checkpoint"
          } >> "$GITHUB_STEP_SUMMARY"
          exit 1
        fi
        
        # Get the most recent checkpoint asset
        LATEST_ASSET=$(echo "$RELEASE_JSON" | jq -r '.assets | sort_by(.created_at) | reverse | .[0]')
        ASSET_NAME=$(echo "$LATEST_ASSET" | jq -r '.name')
        ASSET_URL=$(echo "$LATEST_ASSET" | jq -r '.url')
        ASSET_SIZE=$(echo "$LATEST_ASSET" | jq -r '.size')
        
        if [ "$ASSET_NAME" = "null" ] || [ -z "$ASSET_NAME" ]; then
          echo "::error::No checkpoint assets found in release"
          echo "- âŒ No checkpoint assets found" >> "$GITHUB_STEP_SUMMARY"
          exit 1
        fi
        
        {
          echo "- Checkpoint: \`$ASSET_NAME\`"
          echo "- Size: \`$(numfmt --to=iec-i --suffix=B "$ASSET_SIZE")\`"
        } >> "$GITHUB_STEP_SUMMARY"
        
        # Download checkpoint
        echo "Downloading checkpoint: $ASSET_NAME"
        curl -L -H "Authorization: token $BACKUP_PAT" \
          -H "Accept: application/octet-stream" \
          "$ASSET_URL" -o "$ASSET_NAME"
        
        # Extract checkpoint
        echo "Extracting checkpoint..."
        mkdir -p data
        tar -xzf "$ASSET_NAME" -C data/
        
        # Verify extraction
        if [ ! -d "data/freesound_library" ]; then
          echo "::error::Checkpoint extraction failed"
          echo "- âŒ Extraction failed" >> "$GITHUB_STEP_SUMMARY"
          exit 1
        fi
        
        {
          echo "- âœ… Checkpoint restored successfully"
          echo ""
        } >> "$GITHUB_STEP_SUMMARY"
    

    
    - name: Check checkpoint availability
      id: checkpoint_check
      run: |
        # Check if we have a checkpoint from either cache or repo
        if [ ! -d "data/freesound_library" ] || [ ! "$(ls -A data/freesound_library 2>/dev/null)" ]; then
          {
            echo "### âš ï¸  No Checkpoint Available"
            echo ""
            echo "This is expected for the first pipeline run."
            echo ""
            echo "**Status:** Skipping repair (no data to repair yet)"
            echo ""
            echo "**Next Steps:**"
            echo "- Collection data will be used directly"
            echo "- Backup workflow will create initial checkpoint"
            echo "- Future runs will have checkpoint available for repair"
          } >> "$GITHUB_STEP_SUMMARY"
          echo "checkpoint_available=false" >> "$GITHUB_OUTPUT"
        else
          echo "checkpoint_available=true" >> "$GITHUB_OUTPUT"
        fi
    
    - name: Run validation checks
      if: steps.checkpoint_check.outputs.checkpoint_available == 'true'
      id: validation
      run: |
        {
          echo "### ðŸ” Initial Validation Checks"
          echo ""
        } >> "$GITHUB_STEP_SUMMARY"
        
        # Run validation script (without --final flag, so data quality issues won't cause failure)
        # This allows repair to run even when issues are detected
        python scripts/validation/validate_checkpoint.py data/freesound_library 2>&1 | tee validation_output.log
        
        # Check if data quality issues were found by looking for the scan results file
        if [ -f "data/freesound_library/data_quality_scan.json" ]; then
          ISSUES_FOUND=$(python3 -c 'import json; data=json.load(open("data/freesound_library/data_quality_scan.json")); print(data.get("samples_with_issues", 0))' 2>/dev/null || echo "0")
          
          if [ "$ISSUES_FOUND" -gt 0 ]; then
            echo "validation_passed=false" >> "$GITHUB_OUTPUT"
            echo "- Status: âš ï¸  Data quality issues detected ($ISSUES_FOUND samples need repair)" >> "$GITHUB_STEP_SUMMARY"
          else
            echo "validation_passed=true" >> "$GITHUB_OUTPUT"
            echo "- Status: âœ… All checks passed" >> "$GITHUB_STEP_SUMMARY"
          fi
        else
          echo "validation_passed=true" >> "$GITHUB_OUTPUT"
          echo "- Status: âœ… All checks passed" >> "$GITHUB_STEP_SUMMARY"
        fi
        echo "" >> "$GITHUB_STEP_SUMMARY"
    
    - name: Determine max_requests for repair
      if: steps.validation.outputs.validation_passed == 'false' && steps.source.outputs.skip_repair != 'true'
      id: max_requests
      run: |
        # Priority: manual input > checkpoint metadata > default
        MANUAL_MAX="${{ steps.source.outputs.manual_max_requests }}"
        
        if [ -n "$MANUAL_MAX" ] && [ "$MANUAL_MAX" != "0" ]; then
          # Use manual input from workflow_dispatch
          MAX_REQUESTS=$MANUAL_MAX
          echo "Using max_requests: $MAX_REQUESTS (from manual input)"
        elif [ -f "data/freesound_library/checkpoint_metadata.json" ]; then
          # Try to extract from checkpoint metadata using Python
          CHECKPOINT_MAX=$(python3 -c 'import json; data=json.load(open("data/freesound_library/checkpoint_metadata.json")); print(data.get("collection_stats", {}).get("max_requests", 13))' 2>/dev/null || echo "13")
          
          if [ "$CHECKPOINT_MAX" -gt 0 ]; then
            MAX_REQUESTS=$CHECKPOINT_MAX
            echo "Using max_requests: $MAX_REQUESTS (from checkpoint metadata)"
          else
            MAX_REQUESTS=13
            echo "Using max_requests: $MAX_REQUESTS (default)"
          fi
        else
          # Fall back to default
          MAX_REQUESTS=13
          echo "Using max_requests: $MAX_REQUESTS (default)"
        fi
        
        echo "max_requests=$MAX_REQUESTS" >> "$GITHUB_OUTPUT"
    
    - name: Skip repair (validation only mode)
      if: steps.validation.outputs.validation_passed == 'false' && steps.source.outputs.skip_repair == 'true'
      id: skip_repair
      run: |
        {
          echo "### â„¹ï¸  Validation Only Mode"
          echo ""
          echo "Repair was skipped (validation only mode)."
          echo ""
          echo "**Validation Results:**"
          echo "- Issues detected but not repaired"
          echo "- Run with repair enabled to fix issues"
          echo ""
        } >> "$GITHUB_STEP_SUMMARY"
        
        echo "repair_success=skipped" >> "$GITHUB_OUTPUT"
    
    - name: Run comprehensive data quality repair
      if: steps.validation.outputs.validation_passed == 'false' && steps.source.outputs.skip_repair != 'true'
      id: repair
      env:
        FREESOUND_API_KEY: ${{ secrets.FREESOUND_API_KEY }}
      run: |
        MAX_REQUESTS="${{ steps.max_requests.outputs.max_requests }}"
        
        {
          echo "### ðŸ”§ Comprehensive Data Quality Repair"
          echo ""
          echo "Scanning ALL samples for data quality issues..."
          echo "- Checks all fields in all samples"
          echo "- Queues issues by sample ID (up to 150 per batch)"
          echo "- Fetches missing data using efficient batch API"
          echo "- Applies fixes across entire dataset"
          echo "- Max requests: \`${MAX_REQUESTS}\` (same as collection)"
          echo ""
        } >> "$GITHUB_STEP_SUMMARY"
        
        # Run comprehensive data quality repair with same max_requests as collection
        # This script checks ALL samples and ALL fields, then fixes issues in batches
        if python scripts/validation/comprehensive_data_repair.py \
          --checkpoint-dir data/freesound_library \
          --api-key "$FREESOUND_API_KEY" \
          --max-requests "${MAX_REQUESTS}" \
          2>&1 | tee comprehensive_repair_output.log; then
          echo "repair_success=true" >> "$GITHUB_OUTPUT"
          
          # Extract statistics from log
          issues_found=$(grep -oP "(?<=Issues found: )\d+" comprehensive_repair_output.log | tail -1 || echo "0")
          issues_fixed=$(grep -oP "(?<=Issues fixed: )\d+" comprehensive_repair_output.log | tail -1 || echo "0")
          marked_unavailable=$(grep -oP "(?<=Marked unavailable: )\d+" comprehensive_repair_output.log | tail -1 || echo "0")
          api_requests=$(grep -oP "(?<=API requests used: )\d+" comprehensive_repair_output.log | tail -1 || echo "0")
          
          {
            echo "**Results:**"
            echo "- Issues found: \`${issues_found}\`"
            echo "- Issues fixed: \`${issues_fixed}\`"
            echo "- Marked unavailable: \`${marked_unavailable}\`"
            echo "- API requests used: \`${api_requests}/${MAX_REQUESTS}\`"
            echo ""
            echo "âœ… Comprehensive repair completed successfully"
          } >> "$GITHUB_STEP_SUMMARY"
        else
          echo "repair_success=false" >> "$GITHUB_OUTPUT"
          echo "- Status: âŒ Comprehensive repair failed" >> "$GITHUB_STEP_SUMMARY"
          exit 1
        fi
        echo "" >> "$GITHUB_STEP_SUMMARY"
    
    - name: Re-validate after repairs
      if: steps.repair.outputs.repair_success == 'true' || steps.skip_repair.outputs.repair_success == 'skipped'
      id: revalidation
      run: |
        {
          echo "### ðŸ” Re-validation After Repairs"
          echo ""
        } >> "$GITHUB_STEP_SUMMARY"
        
        # Run validation again WITHOUT --final flag to check progress
        # Incremental repair means issues may remain for next run
        python scripts/validation/validate_checkpoint.py data/freesound_library 2>&1 | tee revalidation_output.log
        
        # Check if issues were reduced
        if [ -f "data/freesound_library/data_quality_scan.json" ]; then
          REMAINING_ISSUES=$(python3 -c 'import json; data=json.load(open("data/freesound_library/data_quality_scan.json")); print(data.get("samples_with_issues", 0))' 2>/dev/null || echo "0")
          
          if [ "$REMAINING_ISSUES" -eq 0 ]; then
            echo "revalidation_passed=true" >> "$GITHUB_OUTPUT"
            {
              echo "- Status: âœ… All issues resolved"
              echo "- Remaining issues: \`0\`"
            } >> "$GITHUB_STEP_SUMMARY"
          else
            # Partial success - issues remain but repair made progress
            echo "revalidation_passed=true" >> "$GITHUB_OUTPUT"
            {
              echo "- Status: âš ï¸  Partial repair (incremental progress)"
              echo "- Remaining issues: \`$REMAINING_ISSUES\`"
              echo ""
              echo "**Note:** Repair is incremental. Remaining issues will be fixed in next run."
            } >> "$GITHUB_STEP_SUMMARY"
          fi
        else
          echo "revalidation_passed=true" >> "$GITHUB_OUTPUT"
          echo "- Status: âœ… All checks passed" >> "$GITHUB_STEP_SUMMARY"
        fi
        echo "" >> "$GITHUB_STEP_SUMMARY"
    
    # Debug: List checkpoint files before caching
    - name: Debug - List checkpoint files
      if: always() && steps.checkpoint_check.outputs.checkpoint_available == 'true'
      run: |
        echo "Listing checkpoint directory contents:"
        ls -laR data/freesound_library/ || echo "Directory not found"
        echo ""
        echo "File sizes:"
        du -h data/freesound_library/* || echo "No files found"
        echo ""
        echo "Total directory size:"
        du -sh data/freesound_library/ || echo "Directory not found"
    
    # Save to cache for downstream workflows (incremental repair)
    # Save even if revalidation fails - repair made progress and should be preserved
    - name: Save checkpoint to cache (for downstream workflows)
      if: always() && steps.checkpoint_check.outputs.checkpoint_available == 'true' && (steps.validation.outputs.validation_passed == 'true' || steps.repair.outputs.repair_success == 'true')
      id: cache_save
      uses: actions/cache/save@v3
      with:
        path: data/freesound_library
        key: checkpoint-repaired-${{ github.run_id }}
    
    - name: Verify cache integrity and warn if permanent storage failed
      if: always() && (steps.validation.outputs.validation_passed == 'true' || (steps.repair.outputs.repair_success == 'true' && steps.revalidation.outputs.revalidation_passed == 'true'))
      run: |
        {
          echo "### ðŸ” Cache Verification"
          echo ""
        } >> "$GITHUB_STEP_SUMMARY"
        
        # Verify checkpoint files exist
        CHECKPOINT_DIR="data/freesound_library"
        
        if [ ! -d "$CHECKPOINT_DIR" ]; then
          echo "::error::Checkpoint directory not found"
          echo "- âŒ Directory not found" >> "$GITHUB_STEP_SUMMARY"
          exit 1
        fi
        
        # Check all three required files
        missing_files=0
        
        if [ ! -f "$CHECKPOINT_DIR/graph_topology.gpickle" ]; then
          echo "::error::Missing graph_topology.gpickle"
          echo "- âŒ Missing: graph_topology.gpickle" >> "$GITHUB_STEP_SUMMARY"
          missing_files=$((missing_files + 1))
        else
          graph_size=$(stat -f%z "$CHECKPOINT_DIR/graph_topology.gpickle" 2>/dev/null || stat -c%s "$CHECKPOINT_DIR/graph_topology.gpickle")
          echo "- âœ… graph_topology.gpickle ($(numfmt --to=iec-i --suffix=B "$graph_size"))" >> "$GITHUB_STEP_SUMMARY"
        fi
        
        if [ ! -f "$CHECKPOINT_DIR/metadata_cache.db" ]; then
          echo "::error::Missing metadata_cache.db"
          echo "- âŒ Missing: metadata_cache.db" >> "$GITHUB_STEP_SUMMARY"
          missing_files=$((missing_files + 1))
        else
          db_size=$(stat -f%z "$CHECKPOINT_DIR/metadata_cache.db" 2>/dev/null || stat -c%s "$CHECKPOINT_DIR/metadata_cache.db")
          echo "- âœ… metadata_cache.db ($(numfmt --to=iec-i --suffix=B "$db_size"))" >> "$GITHUB_STEP_SUMMARY"
        fi
        
        if [ ! -f "$CHECKPOINT_DIR/checkpoint_metadata.json" ]; then
          echo "::error::Missing checkpoint_metadata.json"
          echo "- âŒ Missing: checkpoint_metadata.json" >> "$GITHUB_STEP_SUMMARY"
          missing_files=$((missing_files + 1))
        else
          meta_size=$(stat -f%z "$CHECKPOINT_DIR/checkpoint_metadata.json" 2>/dev/null || stat -c%s "$CHECKPOINT_DIR/checkpoint_metadata.json")
          echo "- âœ… checkpoint_metadata.json ($(numfmt --to=iec-i --suffix=B "$meta_size"))" >> "$GITHUB_STEP_SUMMARY"
        fi
        
        if [ "$missing_files" -gt 0 ]; then
          echo "::error::Cache save verification failed - $missing_files files missing"
          {
            echo ""
            echo "âš ï¸ **WARNING**: Cache was saved but is incomplete!"
            echo "âš ï¸ **Downstream workflows may fail!**"
            echo ""
          } >> "$GITHUB_STEP_SUMMARY"
          exit 1
        fi
        
        # Cache saved successfully
        {
          echo ""
          echo "âœ… All checkpoint files verified"
          echo "âœ… Cache key: \`checkpoint-repaired-${{ github.run_id }}\`"
          echo ""
          echo "### âœ… Data Persistence Status"
          echo "- Cache: âœ… Saved (7-day retention)"
          echo "- Permanent storage: â³ Will be handled by backup workflow"
          echo ""
        } >> "$GITHUB_STEP_SUMMARY"
    
    - name: Generate repair summary
      if: always()
      run: |
        {
          echo "---"
          echo ""
          echo "## ðŸ“Š Repair Summary"
          echo ""
        } >> "$GITHUB_STEP_SUMMARY"
        
        if [ "${{ steps.checkpoint_check.outputs.checkpoint_available }}" = "false" ]; then
          {
            echo "### â„¹ï¸  No Checkpoint Available"
            echo ""
            echo "This is expected for the first pipeline run."
            echo ""
            echo "**Status:** Skipped repair (no data to repair yet)"
            echo ""
            echo "**Next Steps:**"
            echo "- Collection data will be used directly"
            echo "- Backup workflow will create initial checkpoint"
            echo "- Future runs will have checkpoint available for repair"
          } >> "$GITHUB_STEP_SUMMARY"
        elif [ "${{ steps.validation.outputs.validation_passed }}" = "true" ]; then
          {
            echo "### âœ… No Repairs Needed"
            echo ""
            echo "All validation checks passed. Checkpoint is healthy."
          } >> "$GITHUB_STEP_SUMMARY"
        elif [ "${{ steps.skip_repair.outputs.repair_success }}" = "skipped" ]; then
          {
            echo "### â„¹ï¸  Validation Only"
            echo ""
            echo "Validation completed in validation-only mode."
            echo ""
            echo "**Results:**"
            echo "- Issues were detected but not repaired"
            echo "- Re-run with repair enabled to fix issues"
          } >> "$GITHUB_STEP_SUMMARY"
        elif [ "${{ steps.repair.outputs.repair_success }}" = "true" ] && [ "${{ steps.revalidation.outputs.revalidation_passed }}" = "true" ]; then
          {
            echo "### âœ… Repairs Successful"
            echo ""
            echo "Checkpoint issues were detected and repair made progress."
            echo ""
            echo "**Actions Taken:**"
            echo "- Validation identified issues"
            echo "- Repair operations applied (incremental)"
            echo "- Re-validation confirmed progress"
            echo "- Repaired checkpoint saved to cache"
            echo ""
            echo "**Note:** Repair is incremental. If issues remain, they will be fixed in the next run."
          } >> "$GITHUB_STEP_SUMMARY"
        elif [ "${{ steps.repair.outputs.repair_success }}" = "false" ]; then
          {
            echo "### âŒ Repairs Failed"
            echo ""
            echo "Repair operations failed. Manual intervention required."
          } >> "$GITHUB_STEP_SUMMARY"
        elif [ "${{ steps.revalidation.outputs.revalidation_passed }}" = "false" ]; then
          {
            echo "### âš ï¸ Repair In Progress"
            echo ""
            echo "Repairs were applied but more issues remain. This is expected for incremental repair."
            echo ""
            echo "**Next Steps:**"
            echo "- Remaining issues will be fixed in the next scheduled run"
            echo "- Each run processes up to max_requests batches"
            echo "- Progress is saved to cache for next run"
          } >> "$GITHUB_STEP_SUMMARY"
        else
          {
            echo "### âŒ Repair Pipeline Error"
            echo ""
            echo "An unexpected error occurred during the repair process."
          } >> "$GITHUB_STEP_SUMMARY"
        fi
        
        {
          echo ""
          echo "### ðŸ“‹ Execution Details"
          echo ""
          echo "| Detail | Value |"
          echo "|--------|-------|"
          echo "| **Workflow Run** | [#${{ github.run_number }}](https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}) |"
          echo "| **Trigger** | \`${{ github.event_name }}\` |"
        } >> "$GITHUB_STEP_SUMMARY"
        if [ "${{ github.event_name }}" = "workflow_run" ]; then
          echo "| **Source Workflow** | [Run #${{ github.event.workflow_run.run_number }}](https://github.com/${{ github.repository }}/actions/runs/${{ github.event.workflow_run.id }}) |" >> "$GITHUB_STEP_SUMMARY"
        fi
        {
          echo "| **Checkpoint Source** | \`${{ steps.source.outputs.source }}\` |"
          echo ""
        } >> "$GITHUB_STEP_SUMMARY"
    
    - name: Upload repair logs
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: repair-logs-${{ github.run_id }}
        path: |
          *.log
          validation_output.log
          repair_output.log
        retention-days: 30
        if-no-files-found: ignore
    
    - name: Mark workflow as successful if no checkpoint available
      if: steps.checkpoint_check.outputs.checkpoint_available == 'false'
      run: |
        echo "âœ… Workflow completed successfully (no checkpoint to repair)"
        exit 0
    
    - name: Create issue on failure
      if: failure()
      continue-on-error: true
      uses: actions/github-script@v7
      with:
        script: |
          const issue_body = `## ðŸ”§ Repair Pipeline Failed
          
          The data repair pipeline encountered an error and could not complete successfully.
          
          ### Details
          - **Workflow Run:** [#${{ github.run_number }}](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})
          - **Trigger:** \`${{ github.event_name }}\`
          - **Branch:** \`${{ github.ref_name }}\`
          - **Timestamp:** ${new Date().toISOString()}
          
          ### Possible Causes
          - Checkpoint files corrupted beyond repair
          - Database connection issues
          - Insufficient disk space
          - Network connectivity problems
          
          ### Next Steps
          1. Review the [workflow logs](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})
          2. Download repair logs from artifacts
          3. Check checkpoint integrity manually
          4. Consider restoring from backup if needed
          
          ### Artifacts
          - Repair logs available in workflow artifacts (30-day retention)
          
          ---
          *This issue was automatically created by the repair pipeline.*`;
          
          github.rest.issues.create({
            owner: context.repo.owner,
            repo: context.repo.repo,
            title: `ðŸ”§ Repair Pipeline Failed - Run #${{ github.run_number }}`,
            body: issue_body,
            labels: ['automated', 'repair-failure', 'needs-investigation']
          });
