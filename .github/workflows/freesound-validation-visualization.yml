name: Freesound Validation & Visualization

on:
  workflow_run:
    workflows: ["Freesound Data Repair"]
    types: [completed]
    branches: [main]
  
  workflow_dispatch:
    # Allow manual triggering for testing

# Prevent workflow collisions
concurrency:
  group: freesound-validation
  cancel-in-progress: false

# Grant write permissions for committing changes
permissions:
  contents: write

jobs:
  validate-and-visualize:
    name: Validate Data & Generate Visualization
    runs-on: ubuntu-latest
    timeout-minutes: 60
    # Only run if repair pipeline succeeded
    if: ${{ github.event.workflow_run.conclusion == 'success' || github.event_name == 'workflow_dispatch' }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
    
    - name: Configure Git
      run: |
        git config user.name "GitHub Actions Bot"
        git config user.email "actions@github.com"
        git config --global init.defaultBranch main
        git config --global advice.detachedHead false
    
    - name: Set up Python 3.11
      uses: actions/setup-python@v5
      with:
        python-version: '3.11'
        cache: 'pip'
        cache-dependency-path: 'FollowWeb/requirements.txt'
    
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip setuptools wheel
        pip install -r FollowWeb/requirements.txt
        pip install -e FollowWeb/
    
    - name: Verify installation
      run: |
        python -c "import FollowWeb_Visualizor"
        echo "âœ… FollowWeb package imported successfully"
        python -c "from FollowWeb_Visualizor.data.loaders import IncrementalFreesoundLoader"
        echo "âœ… IncrementalFreesoundLoader available"
        python -c "from FollowWeb_Visualizor.visualization.renderers import SigmaRenderer"
        echo "âœ… SigmaRenderer available"
    
    - name: Set execution parameters
      id: params
      run: |
        echo "execution_id=$(date +'%Y%m%d_%H%M%S')" >> "$GITHUB_OUTPUT"
        
        # Determine cache key based on trigger
        if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
          # For manual runs, try to restore from latest cache or download from repo
          {
            echo "cache_key=checkpoint-repaired-"
            echo "use_cache=true"
            echo "allow_fallback=true"
          } >> "$GITHUB_OUTPUT"
        else
          # For triggered runs, use cache from repair pipeline
          # The repair workflow saves with its own run ID, so we use that
          {
            echo "cache_key=checkpoint-repaired-${{ github.event.workflow_run.id }}"
            echo "use_cache=true"
            echo "allow_fallback=false"
          } >> "$GITHUB_OUTPUT"
        fi

    - name: Display workflow configuration
      run: |
        {
          echo "## ðŸ” Validation & Visualization Workflow"
          echo ""
          echo "**Configuration:**"
          echo "- Execution ID: \`${{ steps.params.outputs.execution_id }}\`"
          echo "- Trigger: \`${{ github.event_name }}\`"
        } >> "$GITHUB_STEP_SUMMARY"
        if [ "${{ steps.params.outputs.use_cache }}" = "true" ]; then
          {
            echo "- Cache Key: \`${{ steps.params.outputs.cache_key }}\`"
            echo "- Upstream Run: [#${{ github.event.workflow_run.run_number }}](https://github.com/${{ github.repository }}/actions/runs/${{ github.event.workflow_run.id }})"
          } >> "$GITHUB_STEP_SUMMARY"
        else
          echo "- Source: Manual run (using checkpoint from repository)" >> "$GITHUB_STEP_SUMMARY"
        fi
        echo "" >> "$GITHUB_STEP_SUMMARY"
    
    - name: Restore checkpoint from cache
      if: steps.params.outputs.use_cache == 'true'
      uses: actions/cache/restore@v3
      id: cache-restore
      with:
        path: data/freesound_library
        key: ${{ steps.params.outputs.cache_key }}
        restore-keys: |
          checkpoint-repaired-
          checkpoint-
        fail-on-cache-miss: false
    
    - name: Check cache restore status
      if: steps.params.outputs.use_cache == 'true'
      id: cache-check
      run: |
        # Check if cache was actually restored by verifying directory exists
        # Note: cache-hit is false when restore-keys are used, even if cache was restored
        if [ -d "data/freesound_library" ] && [ "$(ls -A data/freesound_library 2>/dev/null)" ]; then
          echo "âœ… Cache restored successfully"
          if [ "${{ steps.cache-restore.outputs.cache-hit }}" = "true" ]; then
            echo "  - Exact match: ${{ steps.params.outputs.cache_key }}"
          else
            echo "  - Fallback match: ${{ steps.cache-restore.outputs.cache-matched-key }}"
          fi
          echo "cache_restored=true" >> "$GITHUB_OUTPUT"
        else
          {
            echo "## âš ï¸  Cache Restore Failed"
            echo ""
            echo "**Cache Key:** \`${{ steps.params.outputs.cache_key }}\`"
            echo ""
            echo "**Attempting fallback to backup repository...**"
          } >> "$GITHUB_STEP_SUMMARY"
          echo "cache_restored=false" >> "$GITHUB_OUTPUT"
        fi
    
    - name: Restore from backup repository
      if: steps.cache-check.outputs.cache_restored != 'true'
      id: backup-restore
      env:
        BACKUP_PAT: ${{ secrets.BACKUP_PAT }}
      run: |
        echo "Cache restore failed - downloading from backup repository..."
        
        REPO_OWNER="${{ github.repository_owner }}"
        BACKUP_REPO="${REPO_OWNER}/freesound-backup"
        
        # Check if BACKUP_PAT is configured
        if [ -z "$BACKUP_PAT" ]; then
          echo "âš ï¸  BACKUP_PAT not configured - cannot download from backup"
          echo "backup_restored=false" >> "$GITHUB_OUTPUT"
          exit 0
        fi
        
        RELEASE_JSON=$(curl -s -H "Authorization: token $BACKUP_PAT" \
          "https://api.github.com/repos/${BACKUP_REPO}/releases/tags/v-checkpoint")
        
        if echo "$RELEASE_JSON" | grep -q "Not Found"; then
          echo "âš ï¸  v-checkpoint release not found in backup repository"
          echo "This is expected for first pipeline run."
          echo "backup_restored=false" >> "$GITHUB_OUTPUT"
          exit 0
        fi
        
        # Get latest checkpoint backup (highest node count, most recent)
        LATEST_ASSET=$(echo "$RELEASE_JSON" | jq -r '
          .assets 
          | map(select(.name | test("checkpoint_backup_[0-9]+nodes")))
          | map(. + {node_count: (.name | capture("(?<nodes>[0-9]+)nodes") | .nodes | tonumber)})
          | map(select(.node_count > 0))
          | sort_by([-.node_count, .created_at])
          | reverse
          | .[0]')
        
        ASSET_NAME=$(echo "$LATEST_ASSET" | jq -r '.name')
        ASSET_URL=$(echo "$LATEST_ASSET" | jq -r '.url')
        
        if [ "$ASSET_NAME" = "null" ] || [ -z "$ASSET_NAME" ]; then
          echo "âš ï¸  No valid checkpoint backups found in v-checkpoint release"
          echo "backup_restored=false" >> "$GITHUB_OUTPUT"
          exit 0
        fi
        
        echo "Found backup: $ASSET_NAME"
        echo "Downloading..."
        
        curl -L -H "Authorization: token $BACKUP_PAT" \
          -H "Accept: application/octet-stream" \
          "$ASSET_URL" -o "$ASSET_NAME"
        
        echo "Extracting backup..."
        mkdir -p data
        tar -xzf "$ASSET_NAME" -C data/
        
        if [ ! -d "data/freesound_library" ]; then
          echo "âŒ Extraction failed - checkpoint directory not found"
          echo "backup_restored=false" >> "$GITHUB_OUTPUT"
          exit 1
        fi
        
        echo "âœ… Checkpoint restored from backup repository"
        {
          echo ""
          echo "### âœ… Restored from Backup"
          echo ""
          echo "- Backup: \`$ASSET_NAME\`"
          echo "- Source: \`${BACKUP_REPO}\`"
          echo ""
        } >> "$GITHUB_STEP_SUMMARY"
        
        echo "backup_restored=true" >> "$GITHUB_OUTPUT"
        
        # Clean up downloaded file
        rm -f "$ASSET_NAME"


    
    - name: Verify checkpoint files
      id: verify-checkpoint
      run: |
        echo "Verifying checkpoint files..."
        
        if [ "${{ steps.params.outputs.use_cache }}" = "true" ]; then
          # Check if cache was restored
          if [ ! -d "data/freesound_library" ]; then
            echo "âš ï¸ Cache restore failed - checkpoint directory not found"
            echo "This is expected if the upstream workflow (Repair) skipped due to no data."
            echo "checkpoint_available=false" >> "$GITHUB_OUTPUT"
            {
              echo ""
              echo "### â„¹ï¸  Validation Skipped"
              echo ""
              echo "No checkpoint data found. This is expected if:"
              echo "- Collection pipeline found no new data"
              echo "- Repair pipeline skipped due to no data"
              echo ""
              echo "**Status:** Workflow will complete successfully without generating visualization."
            } >> "$GITHUB_STEP_SUMMARY"
            exit 0
          fi
        fi
        
        echo "checkpoint_available=true" >> "$GITHUB_OUTPUT"
        
        # Check required files exist
        CHECKPOINT_DIR="data/freesound_library"
        
        {
          echo ""
          echo "**Checkpoint Files:**"
          echo ""
        } >> "$GITHUB_STEP_SUMMARY"
        
        missing_files=0
        
        # Verify graph_topology.gpickle
        if [ ! -f "$CHECKPOINT_DIR/graph_topology.gpickle" ]; then
          echo "âŒ Missing graph_topology.gpickle"
          echo "- âŒ Missing: graph_topology.gpickle" >> "$GITHUB_STEP_SUMMARY"
          missing_files=$((missing_files + 1))
        else
          graph_size=$(stat -f%z "$CHECKPOINT_DIR/graph_topology.gpickle" 2>/dev/null || stat -c%s "$CHECKPOINT_DIR/graph_topology.gpickle")
          if [ "$graph_size" -lt 1024 ]; then
            echo "âŒ graph_topology.gpickle too small: $graph_size bytes"
            echo "- âŒ graph_topology.gpickle: Too small ($graph_size bytes)" >> "$GITHUB_STEP_SUMMARY"
            missing_files=$((missing_files + 1))
          else
            echo "âœ… graph_topology.gpickle: $(numfmt --to=iec-i --suffix=B "$graph_size")"
            echo "- âœ… graph_topology.gpickle: \`$(numfmt --to=iec-i --suffix=B "$graph_size")\`" >> "$GITHUB_STEP_SUMMARY"
          fi
        fi
        
        # Verify metadata_cache.db
        if [ ! -f "$CHECKPOINT_DIR/metadata_cache.db" ]; then
          echo "âŒ Missing metadata_cache.db"
          echo "- âŒ Missing: metadata_cache.db" >> "$GITHUB_STEP_SUMMARY"
          missing_files=$((missing_files + 1))
        else
          db_size=$(stat -f%z "$CHECKPOINT_DIR/metadata_cache.db" 2>/dev/null || stat -c%s "$CHECKPOINT_DIR/metadata_cache.db")
          if [ "$db_size" -lt 10240 ]; then
            echo "âŒ metadata_cache.db too small: $db_size bytes"
            echo "- âŒ metadata_cache.db: Too small ($db_size bytes)" >> "$GITHUB_STEP_SUMMARY"
            missing_files=$((missing_files + 1))
          else
            echo "âœ… metadata_cache.db: $(numfmt --to=iec-i --suffix=B "$db_size")"
            echo "- âœ… metadata_cache.db: \`$(numfmt --to=iec-i --suffix=B "$db_size")\`" >> "$GITHUB_STEP_SUMMARY"
          fi
        fi
        
        # Verify checkpoint_metadata.json
        if [ ! -f "$CHECKPOINT_DIR/checkpoint_metadata.json" ]; then
          echo "âŒ Missing checkpoint_metadata.json"
          echo "- âŒ Missing: checkpoint_metadata.json" >> "$GITHUB_STEP_SUMMARY"
          missing_files=$((missing_files + 1))
        else
          meta_size=$(stat -f%z "$CHECKPOINT_DIR/checkpoint_metadata.json" 2>/dev/null || stat -c%s "$CHECKPOINT_DIR/checkpoint_metadata.json")
          if [ "$meta_size" -lt 100 ]; then
            echo "âŒ checkpoint_metadata.json too small: $meta_size bytes"
            echo "- âŒ checkpoint_metadata.json: Too small ($meta_size bytes)" >> "$GITHUB_STEP_SUMMARY"
            missing_files=$((missing_files + 1))
          else
            echo "âœ… checkpoint_metadata.json: $(numfmt --to=iec-i --suffix=B "$meta_size")"
            echo "- âœ… checkpoint_metadata.json: \`$(numfmt --to=iec-i --suffix=B "$meta_size")\`" >> "$GITHUB_STEP_SUMMARY"
          fi
        fi
        
        if [ "$missing_files" -gt 0 ]; then
          {
            echo ""
            echo "âŒ **Checkpoint verification failed: $missing_files files missing or invalid**"
          } >> "$GITHUB_STEP_SUMMARY"
          exit 1
        fi
        
        echo ""
        echo "âœ… All checkpoint files present and valid"
        echo "" >> "$GITHUB_STEP_SUMMARY"
    
    - name: Validate checkpoint integrity
      id: validation
      if: steps.verify-checkpoint.outputs.checkpoint_available == 'true'
      continue-on-error: true
      run: |
        echo "Running checkpoint validation..."
        echo ""
        
        # Run validation script (data quality issues don't block visualization)
        # Only critical errors (missing files, corrupted checkpoint) should fail
        if python scripts/validation/validate_checkpoint.py data/freesound_library; then
          echo ""
          echo "âœ… Validation passed"
          echo "validation_passed=true" >> "$GITHUB_OUTPUT"
          {
            echo ""
            echo "**Validation Results:**"
            echo "âœ… Validation passed - all checks successful"
          } >> "$GITHUB_STEP_SUMMARY"
        else
          echo ""
          echo "âš ï¸  Validation found issues (see output above)"
          echo "validation_passed=false" >> "$GITHUB_OUTPUT"
          {
            echo ""
            echo "**Validation Results:**"
            echo "âš ï¸  Validation found issues (see output above)"
            echo ""
            echo "**Note:** Data quality issues don't block visualization"
            echo "- Visualization will proceed with available data"
            echo "- Repair workflow handles data quality issues"
            echo "- Check repair workflow logs for fix progress"
          } >> "$GITHUB_STEP_SUMMARY"
          # Don't exit - continue with visualization
        fi

    - name: Generate edges (zero API requests)
      if: steps.validation.outputs.validation_passed == 'true' && steps.verify-checkpoint.outputs.checkpoint_available == 'true'
      id: edge-generation
      run: |
        echo "Generating edges from existing checkpoint data..."
        {
          echo ""
          echo "**Edge Generation:**"
        } >> "$GITHUB_STEP_SUMMARY"
        
        # Generate edges and save statistics
        python scripts/generation/generate_edges.py \
          --checkpoint-dir data/freesound_library \
          --user-edges \
          --pack-edges \
          --tag-edges \
          --tag-threshold 0.3 \
          --output edge_stats.json
        
        # Display edge statistics
        if [ -f edge_stats.json ]; then
          {
            echo "\`\`\`json"
            cat edge_stats.json
            echo "\`\`\`"
          } >> "$GITHUB_STEP_SUMMARY"
          
          # Extract counts for output
          USER_EDGES=$(jq -r '.user_edges_added // 0' edge_stats.json)
          PACK_EDGES=$(jq -r '.pack_edges_added // 0' edge_stats.json)
          TAG_EDGES=$(jq -r '.tag_edges_added // 0' edge_stats.json)
          
          {
            echo "user_edges=$USER_EDGES"
            echo "pack_edges=$PACK_EDGES"
            echo "tag_edges=$TAG_EDGES"
          } >> "$GITHUB_OUTPUT"
          
          echo "âœ… Generated $USER_EDGES user edges, $PACK_EDGES pack edges, $TAG_EDGES tag edges"
        else
          echo "âš ï¸  Edge statistics file not found"
        fi

    - name: Detect change type
      if: steps.validation.outputs.validation_passed == 'true' && steps.verify-checkpoint.outputs.checkpoint_available == 'true'
      id: change-detection
      run: |
        echo "Detecting type of changes..."
        
        # Check collection_stats to see if nodes/edges were added
        NODES_ADDED=$(python3 -c 'import json; data=json.load(open("data/freesound_library/checkpoint_metadata.json")); print(data.get("collection_stats", {}).get("nodes_added", 0))' 2>/dev/null || echo "0")
        EDGES_ADDED=$(python3 -c 'import json; data=json.load(open("data/freesound_library/checkpoint_metadata.json")); print(data.get("collection_stats", {}).get("edges_added", 0))' 2>/dev/null || echo "0")
        
        # Get total counts for display
        TOTAL_NODES=$(python3 -c 'import json; data=json.load(open("data/freesound_library/checkpoint_metadata.json")); print(data.get("nodes", 0))')
        TOTAL_EDGES=$(python3 -c 'import json; data=json.load(open("data/freesound_library/checkpoint_metadata.json")); print(data.get("edges", 0))')
        
        # If no nodes/edges were added, this is metadata-only
        if [ "$NODES_ADDED" = "0" ] && [ "$EDGES_ADDED" = "0" ]; then
          echo "metadata_only=true" >> "$GITHUB_OUTPUT"
          {
            echo "- Change type: **Metadata only** (no topology changes)"
            echo "- Nodes added: 0 (total: $TOTAL_NODES)"
            echo "- Edges added: 0 (total: $TOTAL_EDGES)"
            echo "- Action: Update data JSON only (fast)"
          } >> "$GITHUB_STEP_SUMMARY"
        else
          echo "metadata_only=false" >> "$GITHUB_OUTPUT"
          {
            echo "- Change type: **Topology changed**"
            echo "- Nodes added: $NODES_ADDED (total: $TOTAL_NODES)"
            echo "- Edges added: $EDGES_ADDED (total: $TOTAL_EDGES)"
            echo "- Action: Full visualization regeneration"
          } >> "$GITHUB_STEP_SUMMARY"
        fi

    - name: Update metadata only (fast path)
      if: steps.validation.outputs.validation_passed == 'true' && steps.change-detection.outputs.metadata_only == 'true' && steps.verify-checkpoint.outputs.checkpoint_available == 'true'
      id: metadata-update
      run: |
        echo "Updating graph data JSON with latest metadata..."
        {
          echo ""
          echo "**Metadata Update (Fast Path):**"
        } >> "$GITHUB_STEP_SUMMARY"
        
        python scripts/visualization/update_metadata_only.py \
          --checkpoint-dir data/freesound_library \
          --output-file Output/graph_data.json
        
        if [ -f "Output/graph_data.json" ]; then
          FILE_SIZE=$(du -h Output/graph_data.json | cut -f1)
          {
            echo "visualization_generated=true"
            echo "visualization_file=Output/graph_data.json"
          } >> "$GITHUB_OUTPUT"
          {
            echo "âœ… Graph data JSON updated"
            echo "- File: \`graph_data.json\`"
            echo "- Size: $FILE_SIZE"
            echo "- Method: Metadata-only update (no HTML regeneration)"
          } >> "$GITHUB_STEP_SUMMARY"
        else
          echo "visualization_generated=false" >> "$GITHUB_OUTPUT"
          echo "âŒ Failed to generate graph data JSON" >> "$GITHUB_STEP_SUMMARY"
          exit 1
        fi

    - name: Generate Sigma.js visualization (full path)
      if: steps.validation.outputs.validation_passed == 'true' && steps.change-detection.outputs.metadata_only != 'true' && steps.verify-checkpoint.outputs.checkpoint_available == 'true'
      id: visualization
      continue-on-error: true
      env:
        FREESOUND_API_KEY: ${{ secrets.FREESOUND_API_KEY }}
      run: |
        echo "Generating Sigma.js visualization..."
        {
          echo ""
          echo "**Visualization (Full Generation):**"
        } >> "$GITHUB_STEP_SUMMARY"
        
        # Generate visualization from checkpoint with verbose output
        echo "Generating visualization from checkpoint..."
        
        # Run with explicit error capture
        set +e  # Don't exit on error
        python scripts/visualization/visualize_checkpoint.py \
          --checkpoint-dir data/freesound_library \
          --renderer-type sigma \
          --output-dir Output 2>&1 | tee visualization.log
        VIZ_EXIT_CODE=${PIPESTATUS[0]}
        set -e  # Re-enable exit on error
        
        if [ "$VIZ_EXIT_CODE" -eq 0 ]; then
          echo "visualization_generated=true" >> "$GITHUB_OUTPUT"
          echo "âœ… Visualization generated successfully" >> "$GITHUB_STEP_SUMMARY"
        else
          {
            echo "visualization_generated=false"
            echo "âŒ Visualization generation failed (exit code: $VIZ_EXIT_CODE)"
            echo ""
            echo "**Error Log:**"
            echo "\`\`\`"
            tail -n 50 visualization.log || echo "No log available"
            echo "\`\`\`"
            echo ""
            echo "âš ï¸  **Previous visualization remains live on GitHub Pages**"
            echo "âš ï¸  **Backup workflow will NOT be triggered**"
          } >> "$GITHUB_STEP_SUMMARY"
          echo "visualization_generated=false" >> "$GITHUB_OUTPUT"
          echo "âŒ Visualization generation failed with exit code: $VIZ_EXIT_CODE"
          cat visualization.log
          exit 1
        fi
        
        # Find generated visualization
        echo "Checking for generated visualization files..."
        ls -lah Output/ || echo "Output directory is empty or doesn't exist"
        
        VIZ_FILE=$(find Output -maxdepth 1 -name "freesound_*.html" -type f -printf '%T@ %p\n' 2>/dev/null | sort -rn | head -n1 | cut -d' ' -f2-)
        
        if [ -n "$VIZ_FILE" ] && [ -f "$VIZ_FILE" ]; then
          {
            echo "visualization_generated=true"
            echo "visualization_file=$VIZ_FILE"
          } >> "$GITHUB_OUTPUT"
          echo "âœ… Visualization generated: \`$VIZ_FILE\`" >> "$GITHUB_STEP_SUMMARY"
          
          # Get file size
          VIZ_SIZE=$(du -h "$VIZ_FILE" | cut -f1)
          echo "- File size: $VIZ_SIZE" >> "$GITHUB_STEP_SUMMARY"
          
          # Verify file is not empty
          FILE_SIZE_BYTES=$(stat -c%s "$VIZ_FILE")
          if [ "$FILE_SIZE_BYTES" -lt 1024 ]; then
            {
              echo "visualization_generated=false"
              echo "âŒ Visualization file is too small ($FILE_SIZE_BYTES bytes)"
              echo ""
              echo "âš ï¸  **Previous visualization remains live on GitHub Pages**"
              echo "âš ï¸  **Backup workflow will NOT be triggered**"
            } >> "$GITHUB_STEP_SUMMARY"
            echo "visualization_generated=false" >> "$GITHUB_OUTPUT"
            exit 1
          fi
        else
          {
            echo "visualization_generated=false"
            echo "âŒ Visualization file not found in Output directory"
            echo ""
            echo "**Output directory contents:**"
            echo "\`\`\`"
            ls -lah Output/ 2>&1 || echo "Directory doesn't exist"
            echo "\`\`\`"
            echo ""
            echo "âš ï¸  **Previous visualization remains live on GitHub Pages**"
            echo "âš ï¸  **Backup workflow will NOT be triggered**"
          } >> "$GITHUB_STEP_SUMMARY"
          echo "visualization_generated=false" >> "$GITHUB_OUTPUT"
          exit 1
        fi

    - name: Update landing page
      if: steps.validation.outputs.validation_passed == 'true' && (steps.visualization.outputs.visualization_generated == 'true' || steps.metadata-update.outputs.visualization_generated == 'true') && steps.verify-checkpoint.outputs.checkpoint_available == 'true'
      id: landing-page
      continue-on-error: true
      run: |
        # For metadata-only updates, skip landing page regeneration
        if [ "${{ steps.change-detection.outputs.metadata_only }}" = "true" ]; then
          echo "Skipping landing page update (metadata-only change)"
          echo "landing_page_updated=true" >> "$GITHUB_OUTPUT"
          echo "âœ… Landing page unchanged (metadata-only update)" >> "$GITHUB_STEP_SUMMARY"
          exit 0
        fi
        
        echo "Updating landing page..."
        
        # Generate landing page with latest visualization and capture output
        LANDING_OUTPUT=$(python generate_landing_page.py \
          --output-dir . \
          --visualizations "Output/*.html" \
          --plausible-domain "alexm1010.github.io" 2>&1)
        LANDING_EXIT_CODE=$?
        
        if [ "$LANDING_EXIT_CODE" -ne 0 ]; then
          {
            echo "landing_page_updated=false"
            echo "âŒ Landing page update failed"
            echo ""
            echo "**Error Details:**"
            echo "\`\`\`"
            echo "$LANDING_OUTPUT"
            echo "\`\`\`"
          } >> "$GITHUB_STEP_SUMMARY"
          echo "landing_page_updated=false" >> "$GITHUB_OUTPUT"
          exit 1
        fi
        
        echo "landing_page_updated=true" >> "$GITHUB_OUTPUT"
        echo "âœ… Landing page updated"
    
    # Commit visualization and landing page to gh-pages branch
    - name: Commit visualization to gh-pages branch
      if: steps.validation.outputs.validation_passed == 'true' && (steps.visualization.outputs.visualization_generated == 'true' || steps.metadata-update.outputs.visualization_generated == 'true') && steps.landing-page.outputs.landing_page_updated == 'true' && steps.verify-checkpoint.outputs.checkpoint_available == 'true'
      id: deployment
      run: |
        # For metadata-only updates, only update graph_data.json
        if [ "${{ steps.change-detection.outputs.metadata_only }}" = "true" ]; then
          echo "Deploying metadata-only update (graph_data.json only)..."
          
          # Switch to gh-pages branch
          git fetch origin gh-pages:gh-pages 2>/dev/null || true
          git checkout gh-pages || {
            echo "âŒ gh-pages branch not found - cannot deploy metadata-only update"
            exit 1
          }
          
          # Copy updated data file
          if [ -f "Output/graph_data.json" ]; then
            cp Output/graph_data.json graph_data.json
            echo "âœ… Updated graph_data.json"
          else
            echo "âŒ graph_data.json not found in Output/"
            exit 1
          fi
          
          # Commit and push
          git add graph_data.json
          if git diff --cached --quiet; then
            echo "No changes to graph_data.json"
            echo "deployment_successful=true" >> "$GITHUB_OUTPUT"
          else
            git commit -m "ðŸ“Š Update graph metadata (repair workflow)
            
            - Updated metadata fields only
            - No topology changes
            - Automated metadata-only deployment"
            
            git push origin gh-pages
            echo "deployment_successful=true" >> "$GITHUB_OUTPUT"
            echo "âœ… Metadata-only deployment successful"
          fi
          
          exit 0
        fi
        
        # Full deployment path (topology changed)
        echo "Deploying full visualization update..."
        
        # Deploy only essential files to gh-pages for efficiency
        # Keep all visualizations in Output/ on main branch for posterity
        mkdir -p /tmp/gh-pages-content
        
        # Copy landing page (index.html)
        if [ -f "index.html" ]; then
          cp index.html /tmp/gh-pages-content/
          echo "âœ… Copied index.html"
        else
          echo "âŒ index.html not found"
          exit 1
        fi
        
        # Find and copy latest data file with consistent naming
        LATEST_DATA=$(find Output -maxdepth 1 -name "*_data.json" -type f -printf '%T@ %p\n' 2>/dev/null | sort -rn | head -n1 | cut -d' ' -f2-)
        if [ -n "$LATEST_DATA" ] && [ -f "$LATEST_DATA" ]; then
          cp "$LATEST_DATA" /tmp/gh-pages-content/graph_data.json
          echo "âœ… Copied latest data file: $(basename "$LATEST_DATA") â†’ graph_data.json"
        else
          echo "âš ï¸  No data file found in Output/"
        fi
        
        # Copy static assets (CSS, JS, PNG) if they exist
        if find Output -maxdepth 1 -name "*.css" -type f -print -quit | grep -q .; then
          find Output -maxdepth 1 -name "*.css" -type f -exec cp {} /tmp/gh-pages-content/ \;
          echo "âœ… Copied CSS files"
        fi
        
        if find Output -maxdepth 1 -name "*.js" -type f -print -quit | grep -q .; then
          find Output -maxdepth 1 -name "*.js" -type f -exec cp {} /tmp/gh-pages-content/ \;
          echo "âœ… Copied JS files"
        fi
        
        if find Output -maxdepth 1 -name "*.png" -type f -print -quit | grep -q .; then
          find Output -maxdepth 1 -name "*.png" -type f -exec cp {} /tmp/gh-pages-content/ \;
          echo "âœ… Copied PNG files"
        fi
        
        echo ""
        echo "ðŸ“¦ Deployment package contents:"
        find /tmp/gh-pages-content/ -type f -exec ls -lh {} \;
        
        # Remove generated files from working directory before branch switch
        rm -f index.html
        
        # Switch to gh-pages branch (now we can do it cleanly)
        git fetch origin gh-pages:gh-pages 2>/dev/null || true
        git checkout gh-pages || git checkout --orphan gh-pages
        
        # Clear gh-pages and copy new content
        git rm -rf . 2>/dev/null || true
        cp -r /tmp/gh-pages-content/* .
        
        # Stage the new files (only what we copied from /tmp/gh-pages-content)
        git add index.html graph_data.json ./*.png 2>/dev/null || true
        
        # Check if there are actual changes
        if git diff --quiet && git diff --cached --quiet; then
          echo "No changes to commit"
          echo "deployment_successful=true" >> "$GITHUB_OUTPUT"
          {
            echo ""
            echo "**Deployment Status:**"
            echo "- â„¹ï¸  No changes detected"
            echo "- â­ï¸  Pages workflow will deploy existing files"
          } >> "$GITHUB_STEP_SUMMARY"
        else
          echo "Committing changes to gh-pages..."
          
          # Add only Output directory and specific files, exclude checkpoint data
          git add Output/ edge_stats.json graph_data.json index.html || true
          git commit -m "ðŸŽ¨ Update visualization from validation pipeline
          
          Generated: $(date -u +'%Y-%m-%d %H:%M:%S UTC')
          Workflow: ${{ github.workflow }}
          Run: ${{ github.run_number }}"
          
          MAX_RETRIES=3
          RETRY_COUNT=0
          while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            if git push origin gh-pages; then
              echo "âœ… Push successful"
              break
            else
              RETRY_COUNT=$((RETRY_COUNT + 1))
              if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
                echo "âš ï¸  Push failed, retrying ($RETRY_COUNT/$MAX_RETRIES)..."
                sleep 2
                git pull --rebase origin gh-pages || git pull --no-rebase origin gh-pages
              else
                echo "âŒ Push failed after $MAX_RETRIES attempts"
                echo "deployment_successful=false" >> "$GITHUB_OUTPUT"
                {
                  echo ""
                  echo "**Deployment Status:**"
                  echo "- âŒ Failed to push changes after $MAX_RETRIES attempts"
                  echo "- âš ï¸  Git conflict or concurrent workflow detected"
                } >> "$GITHUB_STEP_SUMMARY"
                exit 1
              fi
            fi
          done
          
          echo "deployment_successful=true" >> "$GITHUB_OUTPUT"
          {
            echo ""
            echo "**Deployment Status:**"
            echo "- âœ… Visualization committed to gh-pages branch"
            echo "- â­ï¸  Pages workflow will deploy from gh-pages"
            echo "- ðŸ’¾ Backup workflow will persist to storage"
          } >> "$GITHUB_STEP_SUMMARY"
        fi
    
    # Save checkpoint to cache for downstream workflows
    - name: Save to cache for Pages and Backup workflows
      if: steps.validation.outputs.validation_passed == 'true' && steps.visualization.outputs.visualization_generated == 'true' && steps.deployment.outputs.deployment_successful == 'true' && steps.verify-checkpoint.outputs.checkpoint_available == 'true'
      uses: actions/cache/save@v3
      with:
        path: data/freesound_library
        key: checkpoint-${{ github.run_id }}
    
    - name: Check workflow success
      if: always()
      run: |
        # If checkpoint was missing, we consider it a success (skipped)
        if [ "${{ steps.verify-checkpoint.outputs.checkpoint_available }}" != "true" ]; then
          echo "âœ… Workflow skipped successfully (no checkpoint)"
          exit 0
        fi

        # Only fail if visualization or deployment failed
        # Validation issues are handled by repair workflow and don't block visualization
        
        if [ "${{ steps.visualization.outputs.visualization_generated }}" != "true" ]; then
          echo "âŒ Workflow failed: Visualization was not generated"
          exit 1
        fi
        
        if [ "${{ steps.deployment.outputs.deployment_successful }}" != "true" ]; then
          echo "âŒ Workflow failed: Deployment was not successful"
          exit 1
        fi
        
        echo "âœ… Visualization and deployment completed successfully"
    
    - name: Generate workflow summary
      if: always()
      run: |
        {
          echo ""
          echo "---"
          echo ""
          echo "**Workflow Results:**"
          
          # Validation status
          # Validation status (informational only - doesn't block workflow)
          if [ "${{ steps.validation.outputs.validation_passed }}" = "true" ]; then
            echo "- âœ… Validation: All checks passed"
          else
            echo "- âš ï¸  Validation: Data quality issues found (repair workflow will fix)"
          fi
          
          # Edge generation status
          if [ -n "${{ steps.edge-generation.outputs.user_edges }}" ]; then
            echo "- âœ… Edge Generation: Complete"
            echo "  - User edges: ${{ steps.edge-generation.outputs.user_edges }}"
            echo "  - Pack edges: ${{ steps.edge-generation.outputs.pack_edges }}"
            echo "  - Tag edges: ${{ steps.edge-generation.outputs.tag_edges }}"
          else
            echo "- âš ï¸  Edge Generation: Skipped or failed"
          fi
          
          # Visualization status
          if [ "${{ steps.visualization.outputs.visualization_generated }}" = "true" ]; then
            echo "- âœ… Visualization: Generated"
          else
            echo "- âŒ Visualization: Failed"
          fi
          
          # Deployment status
          if [ "${{ steps.deployment.outputs.deployment_successful }}" = "true" ]; then
            echo "- âœ… Deployment: Complete"
          else
            echo "- âŒ Deployment: Failed"
          fi
          
          echo ""
          echo "**Next Steps:**"
          
          # Determine if backup workflow should be triggered
          WORKFLOW_SUCCESS="false"
          if [ "${{ steps.visualization.outputs.visualization_generated }}" = "true" ] && \
             [ "${{ steps.deployment.outputs.deployment_successful }}" = "true" ]; then
            WORKFLOW_SUCCESS="true"
          fi
          
          if [ "$WORKFLOW_SUCCESS" = "true" ]; then
            echo "- âœ… Backup workflow will be triggered automatically"
            echo "- âœ… Visualization and deployment completed successfully"
            if [ "${{ steps.validation.outputs.validation_passed }}" != "true" ]; then
              echo "- â„¹ï¸  Data quality issues will be fixed by repair workflow"
            fi
          else
            echo "- âš ï¸  **Backup workflow will NOT be triggered**"
            echo "- âš ï¸  **Previous visualization remains live on GitHub Pages**"
            echo ""
            echo "**Failure Reason:**"
            if [ "${{ steps.visualization.outputs.visualization_generated }}" != "true" ]; then
              echo "- Visualization generation failed - check visualization errors above"
            elif [ "${{ steps.deployment.outputs.deployment_successful }}" != "true" ]; then
              echo "- Deployment failed - check deployment errors above"
            fi
            echo ""
            echo "**Recovery Actions:**"
            echo "1. Review error details in the failed step above"
            echo "2. Manually trigger this workflow again after fixes"
          fi
        } >> "$GITHUB_STEP_SUMMARY"

# The backup workflow (freesound-backup.yml) is configured with:
#   on:
#     workflow_run:
#       workflows: ["Freesound Validation & Visualization"]
#       types: [completed]
#       branches: [main]
# AND a job-level condition that checks:
#   github.event.workflow_run.conclusion == 'success'
# This ensures the backup workflow only runs when this validation workflow
# completes successfully. If validation, visualization, or deployment fails,
# the backup workflow will NOT run, preserving the previous valid backup.
