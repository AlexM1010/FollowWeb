<!-- 
    Jinja2 Template File
    This file contains Jinja2 template syntax that will be processed server-side.
    IDE warnings about template syntax are expected and can be ignored.
-->
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Network Visualization - 3449 nodes</title>
    <script src="https://cdn.jsdelivr.net/npm/graphology@0.26.0/dist/graphology.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/sigma@2.4.0/build/sigma.min.js"></script>
    <!-- ForceAtlas2 layout from graphology-library -->
    <script src="https://cdn.jsdelivr.net/npm/graphology-library/dist/graphology-library.min.js"></script>
    <!-- Tone.js for synchronized audio playback -->
    <script src="https://cdn.jsdelivr.net/npm/tone@14.8.49/build/Tone.js"></script>
    <!-- Audio Panel CSS (inlined) -->
    <style>
        Ôªø/* Audio Panel Styles */

#audio-panel {
    position: fixed;
    bottom: 20px;
    left: 20px;
    width: 400px;
    max-width: calc(100vw - 40px);
    background: rgba(30, 30, 40, 0.95);
    backdrop-filter: blur(10px);
    border-radius: 12px;
    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
    border: 1px solid rgba(255, 255, 255, 0.1);
    z-index: 1000;
    font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
}

/* Single Player Styles */
.single-player {
    padding: 20px;
}

.sp-header {
    margin-bottom: 16px;
}

.sp-title {
    font-size: 16px;
    font-weight: 600;
    color: #ffffff;
    margin-bottom: 8px;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
}

.sp-meta {
    display: flex;
    gap: 12px;
    font-size: 13px;
    color: #999;
}

.sp-meta span {
    display: flex;
    align-items: center;
    gap: 4px;
}

.sp-controls {
    display: flex;
    align-items: center;
    gap: 12px;
}

.btn-control {
    width: 40px;
    height: 40px;
    border-radius: 50%;
    border: none;
    background: rgba(76, 175, 80, 0.2);
    color: #4CAF50;
    font-size: 18px;
    cursor: pointer;
    transition: all 0.2s ease;
    display: flex;
    align-items: center;
    justify-content: center;
}

.btn-control:hover {
    background: rgba(76, 175, 80, 0.3);
    transform: scale(1.05);
}

.btn-control.active {
    background: #4CAF50;
    color: white;
}

.sp-timeline-wrapper {
    flex: 1;
    display: flex;
    flex-direction: column;
    gap: 6px;
}

.sp-timeline {
    height: 4px;
    background: rgba(255, 255, 255, 0.1);
    border-radius: 2px;
    overflow: hidden;
    cursor: pointer;
}

.sp-progress {
    height: 100%;
    background: linear-gradient(90deg, #4CAF50, #8BC34A);
    transition: width 0.1s linear;
}

.sp-time {
    font-size: 11px;
    color: #999;
    text-align: center;
}

/* Mix Mode Styles */
.mix-mode {
    padding: 16px;
}

.mix-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 8px;
    padding-bottom: 12px;
    border-bottom: 1px solid rgba(255, 255, 255, 0.1);
}

.mix-title {
    font-size: 14px;
    font-weight: 600;
    color: #ffffff;
}

.mix-master-controls {
    display: flex;
    gap: 6px;
}

.mix-bpm-control {
    display: flex;
    align-items: center;
    gap: 8px;
    margin-bottom: 12px;
    padding: 8px 12px;
    background: rgba(255, 255, 255, 0.05);
    border-radius: 6px;
}

.mix-bpm-control label {
    font-size: 12px;
    color: #999;
    font-weight: 500;
}

.mix-bpm-control input[type="number"] {
    width: 60px;
    padding: 4px 8px;
    background: rgba(255, 255, 255, 0.1);
    border: 1px solid rgba(255, 255, 255, 0.2);
    border-radius: 4px;
    color: #ffffff;
    font-size: 12px;
    text-align: center;
}

.mix-bpm-control input[type="number"]:focus {
    outline: none;
    border-color: #4CAF50;
}

.btn-mini {
    padding: 6px 12px;
    border-radius: 6px;
    border: none;
    background: rgba(76, 175, 80, 0.2);
    color: #4CAF50;
    font-size: 12px;
    cursor: pointer;
    transition: all 0.2s ease;
    font-weight: 500;
}

.btn-mini:hover {
    background: rgba(76, 175, 80, 0.3);
    transform: translateY(-1px);
}

.btn-mini.active {
    background: #4CAF50;
    color: white;
}

.btn-mini.btn-danger {
    background: rgba(244, 67, 54, 0.2);
    color: #F44336;
}

.btn-mini.btn-danger:hover {
    background: rgba(244, 67, 54, 0.3);
}

.mix-list {
    max-height: 300px;
    overflow-y: auto;
    display: flex;
    flex-direction: column;
    gap: 8px;
}

.mix-list::-webkit-scrollbar {
    width: 6px;
}

.mix-list::-webkit-scrollbar-track {
    background: rgba(255, 255, 255, 0.05);
    border-radius: 3px;
}

.mix-list::-webkit-scrollbar-thumb {
    background: rgba(255, 255, 255, 0.2);
    border-radius: 3px;
}

.mix-list::-webkit-scrollbar-thumb:hover {
    background: rgba(255, 255, 255, 0.3);
}

.mix-item {
    background: rgba(255, 255, 255, 0.05);
    border-radius: 8px;
    transition: background 0.2s ease;
    overflow: hidden;
}

.mix-item:hover {
    background: rgba(255, 255, 255, 0.08);
}

.mix-item.collapsed {
    padding: 10px 12px;
}

.mix-item.expanded {
    padding: 0;
}

.mix-header-row {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 10px 12px;
    cursor: pointer;
    user-select: none;
}

.mix-item.expanded .mix-header-row {
    border-bottom: 1px solid rgba(255, 255, 255, 0.1);
}

.expand-icon {
    font-size: 10px;
    color: #999;
    flex-shrink: 0;
    width: 12px;
    transition: transform 0.2s ease;
}

.mix-name {
    flex: 1;
    font-size: 13px;
    color: #ffffff;
    font-weight: 500;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
}

.mix-expanded-content {
    padding: 12px;
}

.mix-timeline {
    height: 4px;
    background: rgba(255, 255, 255, 0.1);
    border-radius: 2px;
    overflow: hidden;
    cursor: pointer;
    margin-bottom: 6px;
}

.mix-progress {
    height: 100%;
    background: linear-gradient(90deg, #4CAF50, #8BC34A);
    transition: width 0.1s linear;
}

.mix-time {
    font-size: 11px;
    color: #999;
    text-align: center;
    margin-bottom: 10px;
}

.mix-controls-row {
    display: flex;
    align-items: center;
    gap: 8px;
    margin-bottom: 12px;
    flex-wrap: wrap;
}

.volume-control {
    display: flex;
    align-items: center;
    gap: 6px;
    flex: 1;
    min-width: 150px;
}

.volume-icon {
    font-size: 14px;
    flex-shrink: 0;
}

.volume-slider {
    flex: 1;
    height: 4px;
    -webkit-appearance: none;
    appearance: none;
    background: rgba(255, 255, 255, 0.1);
    border-radius: 2px;
    outline: none;
}

.volume-slider::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    width: 12px;
    height: 12px;
    background: #4CAF50;
    border-radius: 50%;
    cursor: pointer;
}

.volume-slider::-moz-range-thumb {
    width: 12px;
    height: 12px;
    background: #4CAF50;
    border-radius: 50%;
    cursor: pointer;
    border: none;
}

.volume-percent {
    font-size: 11px;
    color: #999;
    min-width: 35px;
    text-align: right;
}

.mix-metadata {
    padding: 10px;
    background: rgba(0, 0, 0, 0.2);
    border-radius: 6px;
    font-size: 12px;
}

.meta-row {
    display: flex;
    padding: 4px 0;
    color: #ccc;
}

.meta-label {
    font-weight: 600;
    color: #999;
    min-width: 90px;
    flex-shrink: 0;
}

/* Responsive adjustments */
@media (max-width: 600px) {
    #audio-panel {
        width: calc(100vw - 40px);
        left: 20px;
        right: 20px;
    }
    
    .sp-controls {
        flex-wrap: wrap;
    }
    
    .sp-timeline-wrapper {
        width: 100%;
        order: 3;
    }
}
    </style>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html,
        body {
            width: 100%;
            height: 100%;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;

            background: #0a0e27;
            color: #e0e0e0;
            overflow: hidden;
        }

        #container {
            width: 100%;
            height: 100%;
            position: absolute;
            top: 0;
            left: 0;

            background: linear-gradient(135deg, #0a0e27 0%, #1a1e3f 100%);
        }

        #controls {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(26, 30, 63, 0.95);
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            width: 320px;
            max-width: calc(100vw - 40px);
            z-index: 1000;
            max-height: 90vh;
            overflow: hidden;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1), width 0.3s cubic-bezier(0.4, 0, 0.2, 1), max-height 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        #controls.hidden {
            max-height: 60px;
            width: fit-content;
            min-width: auto;
            overflow: hidden;
        }

        #controls-header {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 16px 20px;
            cursor: pointer;
            user-select: none;
            background: rgba(108, 142, 255, 0.1);
            border-radius: 12px 12px 0 0;
            transition: background 0.2s ease;
            min-height: 60px;
            box-sizing: border-box;
        }

        #controls-header:hover {
            background: rgba(108, 142, 255, 0.15);
        }

        #controls-toggle {
            background: transparent;
            color: #6c8eff;
            border: none;
            padding: 4px;
            cursor: pointer;
            font-size: 20px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            line-height: 1;
            width: 28px;
            height: 28px;
            flex-shrink: 0;
        }

        #controls-toggle-icon {
            display: inline-block;
            transition: transform 0.3s ease;
        }

        #controls.hidden #controls-toggle-icon {
            transform: rotate(-90deg);
        }

        #controls h2 {
            margin: 0;
            padding-right: 28px;
            font-size: 18px;
            color: #6c8eff;
            font-weight: 600;
            flex: 1;
        }

        #controls-content {
            padding: 0 20px 20px 20px;
            max-height: calc(90vh - 60px);
            overflow-y: auto;
            overflow-x: hidden;
            opacity: 1;
            transition: opacity 0.2s ease;
        }

        #controls.hidden #controls-content {
            display: none;
        }

        /* Custom scrollbar for controls content */
        #controls-content::-webkit-scrollbar {
            width: 8px;
        }

        #controls-content::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 4px;
        }

        #controls-content::-webkit-scrollbar-thumb {
            background: rgba(108, 142, 255, 0.5);
            border-radius: 4px;
        }

        #controls-content::-webkit-scrollbar-thumb:hover {
            background: rgba(108, 142, 255, 0.7);
        }

        /* Firefox scrollbar */
        #controls-content {
            scrollbar-width: thin;
            scrollbar-color: rgba(108, 142, 255, 0.5) rgba(255, 255, 255, 0.05);
        }

        #stats {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(26, 30, 63, 0.95);
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            min-width: 200px;
            z-index: 1000;
        }

        #stats h3 {
            margin: 0 0 12px 0;
            font-size: 16px;
            color: #6c8eff;
            font-weight: 600;
        }

        .stat-item {
            display: flex;
            justify-content: space-between;
            margin: 8px 0;
            font-size: 14px;
        }

        .stat-label {
            color: #a0a0a0;
        }

        .stat-value {
            color: #ffffff;
            font-weight: 600;
        }

        .control-group {
            margin: 15px 0;
        }

        .control-group label {
            display: block;
            margin-bottom: 8px;
            font-size: 13px;
            color: #a0a0a0;
            font-weight: 500;
        }

        input[type="text"] {
            width: 100%;
            padding: 10px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            color: #ffffff;
            font-size: 14px;
            transition: all 0.3s ease;
        }

        input[type="text"]:focus {
            outline: none;
            border-color: #6c8eff;
            background: rgba(255, 255, 255, 0.08);
        }

        #controls-content button {
            width: 100%;
            padding: 10px;
            margin: 5px 0;
            background: linear-gradient(135deg, #6c8eff 0%, #5a7de8 100%);
            border: none;
            border-radius: 6px;
            color: white;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        #controls-content button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(108, 142, 255, 0.4);
        }

        #controls-content button:active {
            transform: translateY(0);
        }

        #controls-content button.secondary {
            background: linear-gradient(135deg, #4a5568 0%, #2d3748 100%);
        }

        #controls-content button.secondary:hover {
            box-shadow: 0 4px 12px rgba(74, 85, 104, 0.4);
        }

        input[type="range"] {
            width: 100%;
            margin: 8px 0;
            -webkit-appearance: none;
            appearance: none;
            height: 6px;
            border-radius: 3px;
            background: rgba(255, 255, 255, 0.1);
            outline: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #6c8eff;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        input[type="range"]::-webkit-slider-thumb:hover {
            background: #5a7de8;
            transform: scale(1.2);
        }

        input[type="range"]::-moz-range-thumb {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #6c8eff;
            cursor: pointer;
            border: none;
            transition: all 0.3s ease;
        }

        input[type="range"]::-moz-range-thumb:hover {
            background: #5a7de8;
            transform: scale(1.2);
        }

        .slider-value {
            float: right;
            color: #6c8eff;
            font-weight: 600;
            font-size: 12px;
        }

        .physics-controls {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        .physics-controls h3 {
            font-size: 14px;
            color: #6c8eff;
            margin-bottom: 12px;
        }

        #controls-content button.danger {
            background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
        }

        #controls-content button.danger:hover {
            box-shadow: 0 4px 12px rgba(231, 76, 60, 0.4);
        }

        #controls-content button.success {
            background: linear-gradient(135deg, #2ecc71 0%, #27ae60 100%);
        }

        #controls-content button.success:hover {
            box-shadow: 0 4px 12px rgba(46, 204, 113, 0.4);
        }

        #node-info {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(26, 30, 63, 0.95);
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            max-width: 350px;
            display: none;
            z-index: 1001;
        }

        #node-audio-player {
            margin-top: 12px;
            width: 100%;
        }

        .audio-controls {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 6px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .audio-controls button {
            background: linear-gradient(135deg, #6c8eff 0%, #5a7de8 100%);
            border: none;
            border-radius: 50%;
            width: 36px;
            height: 36px;
            color: white;
            font-size: 16px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            flex-shrink: 0;
        }

        .audio-controls button:hover {
            transform: scale(1.1);
            box-shadow: 0 4px 12px rgba(108, 142, 255, 0.4);
        }

        .audio-controls button:active {
            transform: scale(0.95);
        }

        .audio-progress {
            flex: 1;
            height: 6px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
            position: relative;
            cursor: pointer;
        }

        .audio-progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #6c8eff 0%, #5a7de8 100%);
            border-radius: 3px;
            width: 0%;
            transition: width 0.1s linear;
        }

        .audio-time {
            font-size: 11px;
            color: #a0a0a0;
            min-width: 80px;
            text-align: right;
        }

        .audio-volume {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .audio-volume button {
            width: 28px;
            height: 28px;
            font-size: 14px;
        }

        .audio-volume input[type="range"] {
            width: 60px;
            margin: 0;
        }

        .audio-loop-btn {
            opacity: 0.5;
            transition: opacity 0.3s ease;
        }

        .audio-loop-btn.active {
            opacity: 1;
            background: linear-gradient(135deg, #2ecc71 0%, #27ae60 100%) !important;
        }

        /* Multi-player panel */
        #active-players {
            position: absolute;
            top: 20px;
            right: 240px;
            background: rgba(26, 30, 63, 0.95);
            padding: 15px;
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            max-width: 350px;
            max-height: 80vh;
            overflow-y: auto;
            z-index: 1000;
            display: none;
        }

        #active-players.visible {
            display: block;
        }

        #active-players h4 {
            margin: 0 0 12px 0;
            font-size: 14px;
            color: #6c8eff;
            font-weight: 600;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .bpm-control {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 12px;
            padding-bottom: 12px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .bpm-control label {
            font-size: 12px;
            color: #a0a0a0;
            min-width: 40px;
        }

        .bpm-control input[type="number"] {
            width: 60px;
            padding: 4px 8px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            color: #ffffff;
            font-size: 13px;
        }

        .bpm-control button {
            padding: 4px 12px;
            background: linear-gradient(135deg, #6c8eff 0%, #5a7de8 100%);
            border: none;
            border-radius: 4px;
            color: white;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .bpm-control button:hover {
            transform: translateY(-1px);
            box-shadow: 0 2px 8px rgba(108, 142, 255, 0.4);
        }

        .player-item {
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 10px;
            margin-bottom: 10px;
        }

        .player-item-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .player-item-name {
            font-size: 12px;
            color: #ffffff;
            font-weight: 600;
            flex: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .player-item-remove {
            background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
            border: none;
            border-radius: 4px;
            color: white;
            font-size: 11px;
            padding: 3px 8px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .player-item-remove:hover {
            transform: scale(1.05);
            box-shadow: 0 2px 8px rgba(231, 76, 60, 0.4);
        }

        .player-item-controls {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .player-item-controls input[type="range"] {
            flex: 1;
            height: 4px;
            margin: 0;
        }

        #node-info-close {
            position: absolute;
            top: 10px;
            right: 10px;
            background: transparent;
            border: none;
            color: #a0a0a0;
            font-size: 20px;
            cursor: pointer;
            padding: 5px;
            line-height: 1;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 4px;
            transition: all 0.2s ease;
        }

        #node-info-close:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #ffffff;
        }

        #node-info h3 {
            margin: 0 0 12px 0;
            font-size: 16px;
            color: #6c8eff;
            word-break: break-all;
        }

        #node-info p {
            margin: 6px 0;
            font-size: 13px;
            color: #a0a0a0;
        }

        #node-info strong {
            color: #ffffff;
        }

        #legend {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(26, 30, 63, 0.95);
            padding: 15px;
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            z-index: 1000;
        }

        #legend h4 {
            margin: 0 0 10px 0;
            font-size: 14px;
            color: #6c8eff;
            font-weight: 600;
        }

        .legend-item {
            display: flex;
            align-items: center;
            margin: 6px 0;
            font-size: 12px;
        }

        .legend-color {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            margin-right: 8px;
        }

        #tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 10px 12px;
            border-radius: 6px;
            font-size: 12px;
            pointer-events: none;
            z-index: 2000;
            display: none;
            max-width: 250px;
            line-height: 1.5;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        #tooltip.visible {
            display: block;
        }

        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            z-index: 2000;
            background: rgba(0, 0, 0, 0.3);
            padding: 30px 40px;
            border-radius: 12px;
        }

        .spinner {
            border: 4px solid rgba(255, 255, 255, 0.1);
            border-top: 4px solid #6c8eff;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin: 0 auto 15px;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        /* Responsive: Hide title text on narrow screens to prevent overlap with stats */
        @media (max-width: 768px) {

            /* Hide title when collapsed */
            #controls.hidden .controls-title-text {
                display: none;
            }

            /* Hide the entire h2 when collapsed to remove its space */
            #controls.hidden h2 {
                display: none;
            }

            /* Show title when expanded */
            #controls:not(.hidden) .controls-title-text {
                display: inline;
            }

            #controls {
                width: calc(100vw - 40px) !important;
                max-width: 100% !important;
                left: 20px;
                right: auto;
            }

            #controls.hidden {
                width: fit-content !important;
                min-width: auto !important;
                padding: 0 !important;
            }

            #controls-header {
                padding: 12px 16px;
                min-width: auto;
                width: 100%;
                justify-content: center;
                gap: 0;
            }

            /* When expanded, show title with proper gap */
            #controls:not(.hidden) #controls-header {
                gap: 12px;
                justify-content: flex-start;
                padding: 12px 16px;
            }

            #controls.hidden #controls-header {
                width: fit-content;
                padding: 16px;
                border-radius: 12px;
            }

            #controls-content {
                padding: 0 15px 15px 15px;
            }

            input[type="text"],
            #controls-content button {
                font-size: 13px;
            }

            /* Mobile-friendly node info panel */
            #node-info {
                left: 50%;
                bottom: 10px;
                transform: translateX(-50%);
                max-width: calc(100vw - 40px);
                width: 90%;
            }

            /* Hide other panels when settings are expanded on mobile */
            #controls:not(.hidden)~#stats,
            #controls:not(.hidden)~#node-info,
            #controls:not(.hidden)~#legend,
            #controls:not(.hidden)~#active-players {
                display: none !important;
            }

            /* Mobile-friendly active players panel */
            #active-players {
                top: auto;
                bottom: 10px;
                right: 10px;
                left: 10px;
                max-width: calc(100vw - 20px);
                max-height: 50vh;
            }
        }

        @media (max-width: 400px) {
            #controls {
                top: 10px;
                left: 10px;
                right: auto;
                width: calc(100vw - 20px) !important;
                max-width: 100% !important;
            }

            #stats {
                top: 10px;
                right: 10px;
                padding: 12px;
                min-width: 150px;
                font-size: 12px;
            }
        }

        /* Mobile hint for tapping nodes */
        @media (hover: none) and (pointer: coarse) {
            #container::after {
                content: 'üëÜ Tap a node to see details';
                position: absolute;
                bottom: 80px;
                left: 50%;
                transform: translateX(-50%);
                background: rgba(108, 142, 255, 0.9);
                color: white;
                padding: 8px 16px;
                border-radius: 20px;
                font-size: 12px;
                pointer-events: none;
                animation: fadeOut 4s forwards;
                z-index: 999;
            }

            @keyframes fadeOut {

                0%,
                70% {
                    opacity: 1;
                }

                100% {
                    opacity: 0;
                }
            }
        }
    </style>

    <!-- Plausible Analytics -->
    <script defer data-domain="alexm1010.github.io" src="https://plausible.io/js/script.js"></script>

</head>

<body>
    <div id="container">
        <div class="loading" id="loading">
            <div class="spinner"></div>
            <p>Loading visualization data...</p>
        </div>

        <div id="controls">
            <div id="controls-header">
                <button id="controls-toggle" aria-label="Toggle controls">
                    <span id="controls-toggle-icon">‚ò∞</span>
                </button>
                <h2><span class="controls-title-text">‚öôÔ∏è Network Controls</span></h2>
            </div>
            <div id="controls-content">
                <div class="control-group">
                    <label for="search">Search Sample:</label>
                    <input type="text" id="search" placeholder="Enter sample name...">
                </div>
                <button onclick="highlightNode()">Highlight Sample</button>
                <button onclick="resetView()" class="secondary">Reset View</button>
                <button onclick="startLayout()" class="success" id="startLayoutBtn">‚ñ∂ Start Physics</button>
                <button onclick="stopLayout()" class="danger" id="stopLayoutBtn" style="display:none;">‚è∏ Stop
                    Physics</button>

                <div class="control-group">
                    <label>
                        <input type="checkbox" id="showLabels" checked onchange="toggleLabels()"
                            style="width: auto; margin-right: 8px;">
                        Show Node Labels
                    </label>
                </div>

                <div class="control-group">
                    <label>
                        <input type="checkbox" id="showTooltips" checked onchange="toggleTooltips()"
                            style="width: auto; margin-right: 8px;">
                        Show Tooltips on Hover
                    </label>
                </div>

                <div class="physics-controls">
                    <h3>‚öôÔ∏è Physics Settings</h3>

                    <div class="control-group">
                        <label for="linLogMode">
                            <input type="checkbox" id="linLogMode" onchange="updatePhysics()"
                                style="width: auto; margin-right: 8px;">
                            LinLog Mode
                        </label>
                        <small style="display: block; color: #888; font-size: 11px; margin-top: 4px;">
                            Enables logarithmic attraction for better clustering
                        </small>
                    </div>

                    <div class="control-group" id="gravityControl">
                        <label for="gravity">
                            <span id="gravityLabel">Gravity</span>: <span class="slider-value"
                                id="gravityValue">1.0</span>
                        </label>
                        <input type="range" id="gravity" min="0" max="100" step="1" value="50"
                            oninput="handleGravityInput()">
                        <small style="display: block; color: #888; font-size: 11px; margin-top: 4px;" id="gravityHint">
                            Pulls nodes toward center
                        </small>
                    </div>

                    <div class="control-group">
                        <label for="scalingRatio">
                            Physics Scale: <span class="slider-value" id="scalingValue">10</span>
                        </label>
                        <input type="range" id="scalingRatio" min="1" max="200" step="1" value="10"
                            oninput="updatePhysics()">
                        <small style="display: block; color: #888; font-size: 11px; margin-top: 4px;">
                            Controls force calculation spacing
                        </small>
                    </div>

                    <div class="control-group">
                        <label for="visualScale">
                            Visual Scale: <span class="slider-value" id="visualScaleValue">0.5</span>
                        </label>
                        <input type="range" id="visualScale" min="0.1" max="5" step="0.1" value="0.5"
                            oninput="updateVisualScale()">
                        <small style="display: block; color: #888; font-size: 11px; margin-top: 4px;">
                            Adjusts node sizes in viewport
                        </small>
                    </div>

                    <div class="control-group">
                        <label for="edgeWeightInfluence">
                            Edge Weight: <span class="slider-value" id="edgeWeightValue">1.0</span>
                        </label>
                        <input type="range" id="edgeWeightInfluence" min="0" max="2" step="0.1" value="1.0"
                            oninput="updatePhysics()">
                        <small style="display: block; color: #888; font-size: 11px; margin-top: 4px;">
                            How much edge weights affect layout
                        </small>
                    </div>

                    <div class="control-group">
                        <label for="slowDown">
                            Slow Down: <span class="slider-value" id="slowDownValue">5.0</span>
                        </label>
                        <input type="range" id="slowDown" min="0" max="100" step="1" value="50"
                            oninput="handleSlowDownInput()">
                        <small style="display: block; color: #888; font-size: 11px; margin-top: 4px;">
                            Higher = slower, more stable convergence
                        </small>
                    </div>

                    <div class="control-group">
                        <label for="outboundAttractionDistribution">
                            <input type="checkbox" id="outboundAttractionDistribution" onchange="updatePhysics()"
                                style="width: auto; margin-right: 8px;">
                            Outbound Attraction
                        </label>
                        <small style="display: block; color: #888; font-size: 11px; margin-top: 4px;">
                            Hubs attract more strongly
                        </small>
                    </div>

                    <div class="control-group">
                        <label for="adjustSizes">
                            <input type="checkbox" id="adjustSizes" onchange="updatePhysics()"
                                style="width: auto; margin-right: 8px;">
                            Adjust Sizes (Prevent Overlap)
                        </label>
                        <small style="display: block; color: #888; font-size: 11px; margin-top: 4px;">
                            Prevents large nodes from overlapping
                        </small>
                    </div>

                    <div class="control-group">
                        <label for="barnesHutOptimize">
                            <input type="checkbox" id="barnesHutOptimize" checked onchange="updatePhysics()"
                                style="width: auto; margin-right: 8px;">
                            Barnes-Hut Optimize
                        </label>
                        <small style="display: block; color: #888; font-size: 11px; margin-top: 4px;">
                            Faster computation for large graphs
                        </small>
                    </div>

                    <div class="control-group" id="barnesHutThetaControl">
                        <label for="barnesHutTheta">
                            Barnes-Hut Œ∏: <span class="slider-value" id="barnesHutThetaValue">0.5</span>
                        </label>
                        <input type="range" id="barnesHutTheta" min="0.1" max="1.5" step="0.1" value="0.5"
                            oninput="updatePhysics()">
                        <small style="display: block; color: #888; font-size: 11px; margin-top: 4px;">
                            Lower = more accurate, higher = faster
                        </small>
                    </div>
                </div>

                <button onclick="exportView()" class="secondary">Export View</button>
            </div>
        </div>

        <div id="stats">
            <h3>üìä Network Stats</h3>
            <div class="stat-item">
                <span class="stat-label">Nodes:</span>
                <span class="stat-value" id="node-count">3449</span>
            </div>
            <div class="stat-item">
                <span class="stat-label">Edges:</span>
                <span class="stat-value" id="edge-count">41307</span>
            </div>
            <div class="stat-item">
                <span class="stat-label">Avg Degree:</span>
                <span class="stat-value" id="avg-degree">23.95</span>
            </div>
            
            <div class="stat-item">
                <span class="stat-label">Density:</span>
                <span class="stat-value">0.0035</span>
            </div>
            
        </div>

        <div id="active-players">
            <h4>
                üéµ Active Players
                <button onclick="stopAllPlayers()"
                    style="padding: 3px 8px; font-size: 11px; background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);">Stop
                    All</button>
            </h4>
            <div class="bpm-control">
                <label>BPM:</label>
                <input type="number" id="bpm-input" value="120" min="40" max="240" step="1">
                <button onclick="updateBPM()">Set</button>
                <button onclick="toggleTransport()" id="transport-btn">‚ñ∂ Start</button>
            </div>
            <div id="players-list"></div>
        </div>

        <div id="node-info">
            <button id="node-info-close" onclick="closeNodeInfo()" aria-label="Close">√ó</button>
            <h3 id="node-name"></h3>
            <p><strong>User:</strong> <span id="node-user">-</span></p>
            <p><strong>Duration:</strong> <span id="node-duration">0s</span></p>
            <p><strong>Tags:</strong> <span id="node-tags">-</span></p>
            <p><strong>Downloads:</strong> <span id="node-downloads">0</span></p>
            <p><strong>Rating:</strong> <span id="node-rating">-</span></p>
            <p><strong>Connections:</strong> <span id="node-degree">0</span></p>
            
            <p><strong>Centrality:</strong> <span id="node-centrality">0</span></p>
            
            
            <p><strong>Community:</strong> <span id="node-community">-</span></p>
            
            <div id="node-audio-player"></div>
        </div>

        <!-- Audio Panel -->
        <div id="audio-panel">
            <div id="panel-content"></div>
        </div>

        <div id="legend">
            <h4>Node Colors</h4>
            <div id="legend-content">
                <!-- Legend items will be dynamically generated based on actual node data -->
            </div>
        </div>

        <div id="tooltip"></div>
    </div>

    <script>
        // Configuration from Jinja2 template
        const config = {"enable_audio": false, "show_labels": true, "show_tooltips": true, "ui_background_color": "#2d333c", "ui_highlight_color": "#415a76", "ui_text_color": "#b6e0fe"};
        const dataFile = 'graph_data.json';  // External JSON file to load
        
        let graphData = null;  // Will be loaded asynchronously

        let graph, renderer, layoutRunning = false, layoutWorker = null;

        // Track previous state of labels/tooltips before physics
        let labelsBeforePhysics = true;
        let tooltipsBeforePhysics = true;

        // Physics settings - ForceAtlas2 parameters
        let physicsSettings = {
            gravity: 1.0,
            scalingRatio: 10,
            edgeWeightInfluence: 1.0,
            slowDown: 5.0,
            linLogMode: false,
            outboundAttractionDistribution: false,
            adjustSizes: false,
            barnesHutOptimize: true,
            barnesHutTheta: 0.5,
            strongGravityMode: true
        };

        // Track which mode gravity is controlling and store separate values for each mode
        let gravityControlsStrongMode = true; // Start with strong gravity mode

        // Separate settings for LinLog mode vs Normal mode
        // Store as slider positions (0-100) for logarithmic mapping
        let linLogSettings = {
            gravitySlider: 30,  // Maps to ~0.1
            slowDownSlider: 30, // Maps to ~0.1
            scalingRatio: 10,
            edgeWeightInfluence: 1.0
        };

        let normalSettings = {
            gravitySlider: 20,  // Maps to ~0.0025
            slowDownSlider: 100, // Maps to 10
            scalingRatio: 10,
            edgeWeightInfluence: 1.0
        };

        // Logarithmic mapping functions for progressive control
        // Maps slider position (0-100) to actual value (0.0001-10)
        function sliderToValue(sliderPos) {
            // Logarithmic scale: 0.0001 to 10
            // Position 0 = 0.0001, Position 50 = ~0.1, Position 100 = 10
            const minLog = Math.log(0.0001);
            const maxLog = Math.log(10);
            const scale = (maxLog - minLog) / 100;
            return Math.exp(minLog + scale * sliderPos);
        }

        // Maps actual value (0.0001-10) to slider position (0-100)
        function valueToSlider(value) {
            const minLog = Math.log(0.0001);
            const maxLog = Math.log(10);
            const scale = (maxLog - minLog) / 100;
            return Math.round((Math.log(Math.max(0.0001, value)) - minLog) / scale);
        }

        function initGraph() {
            // Initialize Graphology graph
            graph = new graphology.DirectedGraph();

            // Add nodes
            graphData.nodes.forEach(node => {
                graph.addNode(node.key, node.attributes);
            });

            // Add edges
            graphData.edges.forEach(edge => {
                try {
                    if (!graph.hasEdge(edge.source, edge.target)) {
                        graph.addEdge(edge.source, edge.target, edge.attributes || {});
                    }
                } catch (e) {
                    console.warn('Failed to add edge:', edge, e);
                }
            });

            return graph;
        }

        function initRenderer() {
            const container = document.getElementById('container');

            renderer = new Sigma(graph, container, {
                renderEdgeLabels: config.renderEdgeLabels || false,
                renderLabels: config.show_labels !== false,
                defaultNodeColor: config.defaultNodeColor || '#6c8eff',
                defaultEdgeColor: config.defaultEdgeColor || 'rgba(108, 142, 255, 0.2)',
                labelSize: config.labelSize || 12,
                labelColor: { color: config.labelColor || '#ffffff' },
                labelWeight: config.labelWeight || '600',
                minCameraRatio: config.minCameraRatio || 0.1,
                maxCameraRatio: config.maxCameraRatio || 10,
                enableEdgeEvents: true
            });

            // Track touch/click state for mobile support
            let touchState = {
                node: null,
                startX: 0,
                startY: 0,
                startTime: 0,
                moved: false,
                timeout: null
            };

            // Add click event for desktop
            renderer.on('clickNode', ({ node }) => {
                showNodeInfo(node);
            });

            // Track touch start on node
            renderer.on('downNode', ({ node, event }) => {
                // Clear any existing timeout
                if (touchState.timeout) {
                    clearTimeout(touchState.timeout);
                }

                // Record touch start
                touchState.node = node;
                touchState.startX = event.x;
                touchState.startY = event.y;
                touchState.startTime = Date.now();
                touchState.moved = false;

                console.log('Touch start on node:', node);
            });

            // Track camera movement (indicates dragging)
            let lastCameraState = null;
            renderer.getCamera().on('updated', () => {
                if (touchState.node) {
                    const currentState = renderer.getCamera().getState();

                    if (lastCameraState) {
                        // Check if camera moved significantly
                        const dx = Math.abs(currentState.x - lastCameraState.x);
                        const dy = Math.abs(currentState.y - lastCameraState.y);
                        const dr = Math.abs(currentState.ratio - lastCameraState.ratio);

                        if (dx > 0.001 || dy > 0.001 || dr > 0.001) {
                            touchState.moved = true;
                            console.log('Camera moved - drag detected');
                        }
                    }

                    lastCameraState = currentState;
                }
            });

            // Detect tap vs drag on touch end
            renderer.getMouseCaptor().on('mouseup', (event) => {
                if (touchState.node) {
                    const duration = Date.now() - touchState.startTime;

                    console.log('Touch end:', {
                        node: touchState.node,
                        duration: duration + 'ms',
                        moved: touchState.moved
                    });

                    // If touch was quick (<400ms) and didn't move, treat as tap
                    if (!touchState.moved && duration < 400) {
                        console.log('Tap detected - showing node info');
                        showNodeInfo(touchState.node);
                    } else {
                        console.log('Drag detected - not showing node info');
                    }

                    // Reset state
                    touchState.node = null;
                    touchState.moved = false;
                    lastCameraState = null;
                }
            });

            // Add hover events
            renderer.on('enterNode', ({ node }) => {
                if (config.show_tooltips !== false) {
                    showTooltip(node);
                }
                const nodeAttributes = graph.getNodeAttributes(node);
                const currentSize = nodeAttributes.size;
                // Scale up by 1.5x from current visual size
                graph.setNodeAttribute(node, 'size', currentSize * 1.5);
                graph.setNodeAttribute(node, 'hovering', true);
                renderer.refresh();
            });

            renderer.on('leaveNode', ({ node }) => {
                if (config.show_tooltips !== false) {
                    hideTooltip();
                }
                const nodeAttributes = graph.getNodeAttributes(node);
                if (nodeAttributes.hovering) {
                    // Restore to base size with current visual scale
                    const baseSize = baseNodeSizes.get(node) || 5;
                    graph.setNodeAttribute(node, 'size', baseSize * currentVisualScale);
                    graph.setNodeAttribute(node, 'hovering', false);
                }
                renderer.refresh();
            });

            // Mouse move for tooltip positioning
            renderer.getMouseCaptor().on('mousemove', (e) => {
                const tooltip = document.getElementById('tooltip');
                if (tooltip.classList.contains('visible')) {
                    tooltip.style.left = (e.x + 15) + 'px';
                    tooltip.style.top = (e.y + 15) + 'px';
                }
            });

            renderer.refresh();
        }

        function showNodeInfo(nodeId) {
            const attributes = graph.getNodeAttributes(nodeId);
            document.getElementById('node-name').textContent = attributes.name || attributes.label || nodeId;
            document.getElementById('node-user').textContent = attributes.user || '-';

            // Format duration
            const duration = attributes.duration || 0;
            const durationText = duration > 0 ? duration.toFixed(1) + 's' : '-';
            document.getElementById('node-duration').textContent = durationText;

            // Format tags
            const tags = attributes.tags || [];
            const tagsText = Array.isArray(tags) && tags.length > 0 ? tags.slice(0, 5).join(', ') : '-';
            document.getElementById('node-tags').textContent = tagsText;

            // Popularity metrics
            const downloads = attributes.num_downloads || 0;
            document.getElementById('node-downloads').textContent = downloads.toLocaleString();

            const avgRating = attributes.avg_rating || 0;
            const numRatings = attributes.num_ratings || 0;
            const ratingText = numRatings > 0 ? `${avgRating.toFixed(1)}/5 (${numRatings} ratings)` : 'No ratings';
            document.getElementById('node-rating').textContent = ratingText;

            document.getElementById('node-degree').textContent = graph.degree(nodeId);

            
            const centralityElem = document.getElementById('node-centrality');
            if (centralityElem && attributes.centrality !== undefined) {
                centralityElem.textContent = attributes.centrality.toFixed(4);
            }
            

            
            const communityElem = document.getElementById('node-community');
            if (communityElem && attributes.community !== undefined) {
                communityElem.textContent = attributes.community;
            }
            

            // Add audio player if audio_url is available
            const audioPlayerDiv = document.getElementById('node-audio-player');
            audioPlayerDiv.innerHTML = ''; // Clear previous player

            // Parse audio URLs array
            let audioUrls = [];
            if (attributes.audio_urls) {
                try {
                    audioUrls = JSON.parse(attributes.audio_urls);
                } catch (e) {
                    console.error('Failed to parse audio_urls:', e);
                }
            }

            // Trigger audio panel if available
            if (window.audioPanel && window.audioPanel.showSinglePlayer) {
                window.audioPanel.showSinglePlayer(nodeId);
            }
            
            document.getElementById('node-info').style.display = 'block';
        }

        function closeNodeInfo() {
            document.getElementById('node-info').style.display = 'none';
        }

        function showTooltip(nodeId) {
            const attributes = graph.getNodeAttributes(nodeId);
            const tooltip = document.getElementById('tooltip');

            let content = `<strong>${attributes.name || attributes.label || nodeId}</strong><br>`;
            content += `User: ${attributes.user || '-'}<br>`;

            const duration = attributes.duration || 0;
            if (duration > 0) {
                content += `Duration: ${duration.toFixed(1)}s<br>`;
            }

            content += `Connections: ${graph.degree(nodeId)}`;

            
            if (attributes.centrality !== undefined) {
                content += `<br>Centrality: ${attributes.centrality.toFixed(4)}`;
            }
            

            
            if (attributes.community !== undefined) {
                content += `<br>Community: ${attributes.community}`;
            }
            

            tooltip.innerHTML = content;
            tooltip.classList.add('visible');
        }

        function hideTooltip() {
            document.getElementById('tooltip').classList.remove('visible');
        }

        function highlightNode() {
            const searchTerm = document.getElementById('search').value.toLowerCase().trim();
            if (!searchTerm) {
                alert('Please enter a sample name to search');
                return;
            }

            let found = false;
            graph.forEachNode((node, attributes) => {
                const label = (attributes.name || attributes.label || node).toLowerCase();
                if (label.includes(searchTerm)) {
                    // Store original color if not already stored
                    if (!attributes.originalColor) {
                        graph.setNodeAttribute(node, 'originalColor', attributes.color);
                    }

                    // Highlight the node
                    graph.setNodeAttribute(node, 'color', '#ffff00');
                    graph.setNodeAttribute(node, 'highlighted', true);

                    // Make it 2x larger than current visual size
                    const baseSize = baseNodeSizes.get(node) || 5;
                    graph.setNodeAttribute(node, 'size', baseSize * currentVisualScale * 2);

                    // Center camera on node
                    const nodePosition = renderer.getNodeDisplayData(node);
                    if (nodePosition) {
                        renderer.getCamera().animate(nodePosition, {
                            duration: 500
                        });
                    }

                    showNodeInfo(node);
                    found = true;
                    return false; // Stop iteration
                }
            });

            if (!found) {
                alert('Sample not found!');
            } else {
                renderer.refresh();
            }
        }

        function resetView() {
            // Reset all node colors and sizes
            graph.forEachNode((node, attributes) => {
                if (attributes.originalColor) {
                    graph.setNodeAttribute(node, 'color', attributes.originalColor);
                    graph.setNodeAttribute(node, 'originalColor', undefined);
                }
                if (attributes.highlighted) {
                    // Restore to base size with current visual scale
                    const baseSize = baseNodeSizes.get(node) || 5;
                    graph.setNodeAttribute(node, 'size', baseSize * currentVisualScale);
                    graph.setNodeAttribute(node, 'highlighted', false);
                }
            });

            renderer.getCamera().animate({ x: 0.5, y: 0.5, ratio: 1 }, { duration: 500 });
            document.getElementById('node-info').style.display = 'none';
            document.getElementById('search').value = '';
            renderer.refresh();
        }

        function toggleLabels() {
            const showLabels = document.getElementById('showLabels').checked;
            renderer.setSetting('renderLabels', showLabels);
            renderer.refresh();
            console.log('Labels:', showLabels ? 'enabled' : 'disabled');
        }

        function toggleTooltips() {
            const showTooltips = document.getElementById('showTooltips').checked;
            config.show_tooltips = showTooltips;
            console.log('Tooltips:', showTooltips ? 'enabled' : 'disabled');
        }

        // Format value with appropriate precision
        function formatValue(val) {
            if (val < 0.001) return val.toFixed(4);
            if (val < 0.01) return val.toFixed(3);
            if (val < 0.1) return val.toFixed(2);
            return val.toFixed(1);
        }

        // Logarithmic gravity slider handler
        function handleGravityInput() {
            const slider = document.getElementById('gravity');
            const sliderPos = parseInt(slider.value);
            const actualValue = sliderToValue(sliderPos);

            // Save to current mode settings
            const linLogMode = document.getElementById('linLogMode').checked;
            if (linLogMode) {
                linLogSettings.gravitySlider = sliderPos;
            } else {
                normalSettings.gravitySlider = sliderPos;
            }

            // Update physics with actual value
            physicsSettings.gravity = actualValue;

            // Update display
            document.getElementById('gravityValue').textContent = formatValue(actualValue);

            console.log(`Gravity slider: ${sliderPos} ‚Üí value: ${actualValue.toFixed(4)}`);
        }

        // Logarithmic slowDown slider handler
        function handleSlowDownInput() {
            const slider = document.getElementById('slowDown');
            const sliderPos = parseInt(slider.value);
            const actualValue = sliderToValue(sliderPos);

            // Save to current mode settings
            const linLogMode = document.getElementById('linLogMode').checked;
            if (linLogMode) {
                linLogSettings.slowDownSlider = sliderPos;
            } else {
                normalSettings.slowDownSlider = sliderPos;
            }

            // Update physics with actual value
            physicsSettings.slowDown = actualValue;

            // Update display
            document.getElementById('slowDownValue').textContent = formatValue(actualValue);

            console.log(`SlowDown slider: ${sliderPos} ‚Üí value: ${actualValue.toFixed(4)}`);
        }

        // Visual scale handler (affects node sizes in viewport)
        let baseNodeSizes = new Map(); // Store original node sizes
        let currentVisualScale = 0.5;

        function updateVisualScale() {
            const visualScale = parseFloat(document.getElementById('visualScale').value);
            document.getElementById('visualScaleValue').textContent = visualScale.toFixed(1);

            if (!graph) return;

            // Store base sizes on first call
            if (baseNodeSizes.size === 0) {
                graph.forEachNode((node, attributes) => {
                    baseNodeSizes.set(node, attributes.size || 5);
                });
            }

            // Apply visual scale to all node sizes
            graph.forEachNode((node, attributes) => {
                const baseSize = baseNodeSizes.get(node) || attributes.size || 5;
                graph.setNodeAttribute(node, 'size', baseSize * visualScale);
            });

            currentVisualScale = visualScale;

            if (renderer) {
                renderer.refresh();
            }

            console.log(`Visual scale: ${visualScale} (node sizes multiplied)`);
        }

        function updatePhysics() {
            const linLogMode = document.getElementById('linLogMode').checked;
            const barnesHutOptimize = document.getElementById('barnesHutOptimize').checked;

            // Get slider elements
            const gravitySlider = document.getElementById('gravity');
            const slowDownSlider = document.getElementById('slowDown');
            const scalingSlider = document.getElementById('scalingRatio');
            const edgeWeightSlider = document.getElementById('edgeWeightInfluence');

            // Check if mode changed (checkbox was toggled)
            const modeChanged = (linLogMode && gravityControlsStrongMode) || (!linLogMode && !gravityControlsStrongMode);

            if (modeChanged) {
                // Mode switched - restore all settings for the new mode
                if (linLogMode) {
                    // Switching TO LinLog mode - restore LinLog settings
                    gravitySlider.value = linLogSettings.gravitySlider;
                    slowDownSlider.value = linLogSettings.slowDownSlider;
                    scalingSlider.value = linLogSettings.scalingRatio;
                    edgeWeightSlider.value = linLogSettings.edgeWeightInfluence;

                    physicsSettings.strongGravityMode = false;
                    gravityControlsStrongMode = false;

                    document.getElementById('gravityLabel').textContent = 'Gravity';
                    document.getElementById('gravityHint').textContent = 'Pulls nodes toward center (LinLog Mode)';
                    document.getElementById('gravityHint').style.color = '#4ecdc4';
                } else {
                    // Switching TO Normal mode - restore Normal settings
                    gravitySlider.value = normalSettings.gravitySlider;
                    slowDownSlider.value = normalSettings.slowDownSlider;
                    scalingSlider.value = normalSettings.scalingRatio;
                    edgeWeightSlider.value = normalSettings.edgeWeightInfluence;

                    physicsSettings.strongGravityMode = true;
                    gravityControlsStrongMode = true;

                    document.getElementById('gravityLabel').textContent = 'Gravity (Strong)';
                    document.getElementById('gravityHint').textContent = 'Pulls nodes toward center (Strong Mode)';
                    document.getElementById('gravityHint').style.color = '#6c8eff';
                }

                // Trigger input handlers to update actual values
                handleGravityInput();
                handleSlowDownInput();
            } else {
                // No mode change - save regular slider values to current mode
                if (linLogMode) {
                    linLogSettings.scalingRatio = parseFloat(scalingSlider.value);
                    linLogSettings.edgeWeightInfluence = parseFloat(edgeWeightSlider.value);
                } else {
                    normalSettings.scalingRatio = parseFloat(scalingSlider.value);
                    normalSettings.edgeWeightInfluence = parseFloat(edgeWeightSlider.value);
                }
            }

            // Apply current slider values to physics settings
            // Gravity and slowDown are handled by their input handlers
            physicsSettings.scalingRatio = parseFloat(scalingSlider.value);
            physicsSettings.edgeWeightInfluence = parseFloat(edgeWeightSlider.value);
            physicsSettings.barnesHutTheta = parseFloat(document.getElementById('barnesHutTheta').value);
            physicsSettings.linLogMode = linLogMode;
            physicsSettings.outboundAttractionDistribution = document.getElementById('outboundAttractionDistribution').checked;
            physicsSettings.adjustSizes = document.getElementById('adjustSizes').checked;
            physicsSettings.barnesHutOptimize = barnesHutOptimize;

            // Show/hide Barnes-Hut theta control based on optimization setting
            const barnesHutThetaControl = document.getElementById('barnesHutThetaControl');
            barnesHutThetaControl.style.display = barnesHutOptimize ? 'block' : 'none';

            // Update display values for non-logarithmic sliders
            document.getElementById('scalingValue').textContent = physicsSettings.scalingRatio.toFixed(0);
            document.getElementById('edgeWeightValue').textContent = physicsSettings.edgeWeightInfluence.toFixed(1);
            document.getElementById('barnesHutThetaValue').textContent = physicsSettings.barnesHutTheta.toFixed(1);

            // Settings will be applied on next animation frame if layout is running
            console.log('Physics settings updated:', physicsSettings);
            console.log('Mode:', linLogMode ? 'LinLog' : 'Normal (Strong Gravity)');
        }

        function startLayout() {
            if (layoutRunning) {
                console.log('Layout is already running');
                return;
            }

            // Save current state of labels and tooltips
            labelsBeforePhysics = document.getElementById('showLabels').checked;
            tooltipsBeforePhysics = document.getElementById('showTooltips').checked;

            // Disable labels and tooltips for better performance
            if (labelsBeforePhysics) {
                document.getElementById('showLabels').checked = false;
                toggleLabels();
            }
            if (tooltipsBeforePhysics) {
                document.getElementById('showTooltips').checked = false;
                toggleTooltips();
            }

            document.getElementById('loading').style.display = 'block';
            document.getElementById('startLayoutBtn').style.display = 'none';
            document.getElementById('stopLayoutBtn').style.display = 'block';
            layoutRunning = true;

            try {
                // Use graphology-library ForceAtlas2
                if (!window.graphologyLibrary || !window.graphologyLibrary.layoutForceAtlas2) {
                    throw new Error('graphology-library not loaded');
                }

                console.log('Using ForceAtlas2 from graphology-library');

                // Infer base settings from graph structure
                const inferredSettings = window.graphologyLibrary.layoutForceAtlas2.inferSettings(graph);

                // Run layout with animation
                let iteration = 0;
                const maxIterations = 500;

                const animate = () => {
                    if (!layoutRunning || iteration >= maxIterations) {
                        stopLayout();
                        return;
                    }

                    // Merge inferred settings with current user settings (allows live updates)
                    const currentSettings = Object.assign({}, inferredSettings, physicsSettings);

                    // Run one iteration and assign positions to graph
                    window.graphologyLibrary.layoutForceAtlas2.assign(graph, {
                        iterations: 1,
                        settings: currentSettings
                    });

                    iteration++;

                    // Refresh renderer every 3 iterations for smooth performance
                    if (iteration % 3 === 0) {
                        renderer.refresh();
                    }

                    // Continue animation
                    requestAnimationFrame(animate);
                };

                animate();
                console.log('ForceAtlas2 layout started');
            } catch (e) {
                console.error('Layout error:', e);
                alert('Failed to start layout: ' + e.message);
                stopLayout();
            }
        }

        function stopLayout() {
            layoutRunning = false;
            layoutWorker = null;

            document.getElementById('loading').style.display = 'none';
            document.getElementById('startLayoutBtn').style.display = 'block';
            document.getElementById('stopLayoutBtn').style.display = 'none';

            // Restore previous state of labels and tooltips
            if (labelsBeforePhysics) {
                document.getElementById('showLabels').checked = true;
                toggleLabels();
            }
            if (tooltipsBeforePhysics) {
                document.getElementById('showTooltips').checked = true;
                toggleTooltips();
            }

            renderer.refresh();
            console.log('Layout stopped');
        }

        function exportView() {
            // Get current camera state
            const camera = renderer.getCamera();
            const state = camera.getState();

            const exportData = {
                camera: state,
                timestamp: new Date().toISOString(),
                stats: {
                    nodes: graph.order,
                    edges: graph.size
                }
            };

            console.log('Current view state:', exportData);
            alert('View state exported to console. Check browser developer tools.');
        }

        // Generate dynamic legend based on node colors and tags
        function generateLegend() {
            const colorCounts = new Map();
            const colorToTags = new Map();

            // Analyze node colors and associated tags
            graph.forEachNode((node, attributes) => {
                const color = attributes.color || '#6c8eff';
                const tags = attributes.tags || [];

                // Count color occurrences
                colorCounts.set(color, (colorCounts.get(color) || 0) + 1);

                // Associate tags with colors
                if (!colorToTags.has(color)) {
                    colorToTags.set(color, new Map());
                }
                const tagMap = colorToTags.get(color);

                tags.forEach(tag => {
                    if (tag && typeof tag === 'string') {
                        tagMap.set(tag, (tagMap.get(tag) || 0) + 1);
                    }
                });
            });

            // Sort colors by frequency
            const sortedColors = Array.from(colorCounts.entries())
                .sort((a, b) => b[1] - a[1])
                .slice(0, 10); // Top 10 colors

            // Generate legend HTML
            const legendContent = document.getElementById('legend-content');
            legendContent.innerHTML = '';

            if (sortedColors.length === 0) {
                legendContent.innerHTML = '<div class="legend-item"><span>No data available</span></div>';
                return;
            }

            sortedColors.forEach(([color, count]) => {
                const tagMap = colorToTags.get(color);

                // Get top 3 most common tags for this color
                let topTags = [];
                if (tagMap && tagMap.size > 0) {
                    topTags = Array.from(tagMap.entries())
                        .sort((a, b) => b[1] - a[1])
                        .slice(0, 3)
                        .map(([tag]) => tag);
                }

                // Create legend item
                const item = document.createElement('div');
                item.className = 'legend-item';

                const colorBox = document.createElement('div');
                colorBox.className = 'legend-color';
                colorBox.style.background = color;

                const label = document.createElement('span');
                if (topTags.length > 0) {
                    label.textContent = `${topTags.join(', ')} (${count})`;
                } else {
                    label.textContent = `${count} nodes`;
                }
                label.title = `Color: ${color}, Nodes: ${count}`;

                item.appendChild(colorBox);
                item.appendChild(label);
                legendContent.appendChild(item);
            });

            console.log(`Generated legend with ${sortedColors.length} color categories`);
        }

        // Load graph data from external JSON file
        async function loadGraphData() {
            try {
                document.getElementById('loading').style.display = 'block';
                
                const response = await fetch(dataFile);
                if (!response.ok) {
                    throw new Error(`Failed to load data: ${response.status} ${response.statusText}`);
                }
                
                graphData = await response.json();
                console.log('Graph data loaded:', graphData.nodes.length, 'nodes');
                
                return true;
            } catch (error) {
                console.error('Error loading graph data:', error);
                document.getElementById('loading').innerHTML = `
                    <div class="spinner"></div>
                    <p style="color: #e74c3c;">Failed to load visualization data</p>
                    <p style="font-size: 12px; color: #888;">${error.message}</p>
                `;
                return false;
            }
        }

        // Initialize on load
        document.addEventListener('DOMContentLoaded', async () => {
            try {
                // Load external data first
                const loaded = await loadGraphData();
                if (!loaded) return;
                
                initGraph();

                // Store base node sizes before any scaling
                graph.forEachNode((node, attributes) => {
                    baseNodeSizes.set(node, attributes.size || 5);
                });

                initRenderer();

                // Generate dynamic legend based on actual node data
                generateLegend();

                // Set checkbox states based on config
                document.getElementById('showLabels').checked = config.show_labels !== false;
                document.getElementById('showTooltips').checked = config.show_tooltips !== false;

                // Initialize logarithmic sliders with default values
                handleGravityInput();
                handleSlowDownInput();

                // Initialize visual scale (apply 0.5 default)
                updateVisualScale();

                // Initialize physics UI state
                updatePhysics();

                // Initialize controls toggle - hidden by default
                const controlsHeader = document.getElementById('controls-header');
                const controls = document.getElementById('controls');
                let controlsVisible = false;

                // Hide controls by default on all devices
                controls.classList.add('hidden');

                controlsHeader.addEventListener('click', (e) => {
                    e.stopPropagation();
                    controlsVisible = !controlsVisible;
                    if (controlsVisible) {
                        controls.classList.remove('hidden');
                    } else {
                        controls.classList.add('hidden');
                    }
                });

                // Hide loading indicator
                document.getElementById('loading').style.display = 'none';
                
                console.log('Sigma.js visualization initialized');
                console.log('Nodes:', graph.order);
                console.log('Edges:', graph.size);

                // Check if graphology-library is available
                if (window.graphologyLibrary && window.graphologyLibrary.layoutForceAtlas2) {
                    console.log('‚úì graphology-library loaded with ForceAtlas2');
                } else {
                    console.error('‚úó graphology-library failed to load');
                }

                // Initialize Tone.js
                if (window.Tone) {
                    console.log('‚úì Tone.js loaded');
                    Tone.Transport.bpm.value = 120; // Default BPM
                    console.log('Tone.js Transport initialized at 120 BPM');
                } else {
                    console.error('‚úó Tone.js failed to load');
                }
            } catch (e) {
                console.error('Initialization error:', e);
                alert('Failed to initialize visualization: ' + e.message);
            }
        });

        // Keyboard shortcuts
        document.getElementById('search').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                highlightNode();
            }
        });

        // Prevent context menu on container
        document.getElementById('container').addEventListener('contextmenu', (e) => {
            e.preventDefault();
        });
    </script>
    <!-- Audio Panel Logic (inlined) -->
    <script>
        Ôªø// Audio Panel State & Logic (using Tone.js)
(function () {
    'use strict';

    let audioContextStarted = false;

    // Wait for DOM and global variables to be ready
    window.addEventListener('DOMContentLoaded', function () {
        // Check if required globals exist
        if (typeof graph === 'undefined' || typeof renderer === 'undefined') {
            console.error('Audio panel: Required globals (graph, renderer) not found');
            return;
        }

        if (typeof Tone === 'undefined') {
            console.error('Audio panel: Tone.js not found. Please include Tone.js before audio-panel.js');
            return;
        }

        // State management
        const audioState = {
            activePlayers: {}, // Map<nodeId, {player: Tone.Player, duration: number, volume: number, isLooping: boolean, isExpanded: boolean}>
            singlePlayerNode: null, // nodeId
            mixMode: false,
            globalBPM: 120
        };

        // DOM Elements
        const panelContent = document.getElementById('panel-content');
        if (!panelContent) {
            console.error('Audio panel: #panel-content element not found');
            return;
        }

        // --- Helper Functions ---

        async function ensureAudioContext() {
            if (!audioContextStarted) {
                await Tone.start();
                audioContextStarted = true;
                console.log('Tone.js audio context started');
            }
        }

        function formatTime(seconds) {
            if (!seconds || isNaN(seconds)) return '0:00';
            const minutes = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return minutes + ':' + (secs < 10 ? '0' : '') + secs;
        }

        function getNodeData(nodeId) {
            if (!graph.hasNode(nodeId)) return null;
            return {
                id: nodeId,
                ...graph.getNodeAttributes(nodeId)
            };
        }

        // --- Core Functions ---

        async function showSinglePlayer(nodeId) {
            await ensureAudioContext();
            audioState.singlePlayerNode = nodeId;
            audioState.mixMode = false;
            renderAudioPanel();

            if (!audioState.activePlayers[nodeId]) {
                await togglePlay(nodeId);
            }
        }

        async function addToMix(nodeId) {
            await ensureAudioContext();
            if (!audioState.activePlayers[nodeId]) {
                await createPlayer(nodeId);
            }
            audioState.mixMode = true;
            renderAudioPanel();
        }

        function removeFromMix(nodeId) {
            if (audioState.activePlayers[nodeId]) {
                const playerData = audioState.activePlayers[nodeId];
                playerData.player.stop();
                playerData.player.dispose();
                delete audioState.activePlayers[nodeId];
            }

            // If no players left, exit mix mode
            if (Object.keys(audioState.activePlayers).length === 0) {
                audioState.mixMode = false;
                audioState.singlePlayerNode = null;
            }

            highlightPlayingNode(nodeId, false);
            renderAudioPanel();
        }

        async function createPlayer(nodeId) {
            const node = getNodeData(nodeId);
            if (!node || !node.audio_url) {
                console.warn('No audio URL for node:', nodeId);
                return null;
            }

            try {
                const player = new Tone.Player({
                    url: node.audio_url,
                    loop: false,
                    onload: () => {
                        // Store duration once loaded
                        if (audioState.activePlayers[nodeId]) {
                            audioState.activePlayers[nodeId].duration = player.buffer.duration;
                        }
                        renderAudioPanel();
                    }
                }).toDestination();

                // Set up event handlers
                player.onstop = () => {
                    highlightPlayingNode(nodeId, false);
                    renderAudioPanel();
                };

                audioState.activePlayers[nodeId] = {
                    player: player,
                    duration: 0, // Will be set on load
                    volume: 0.8,
                    isLooping: false,
                    isExpanded: false,
                    startTime: null
                };

                player.volume.value = Tone.gainToDb(0.8);

                return player;
            } catch (error) {
                console.error('Error creating player for node:', nodeId, error);
                return null;
            }
        }

        async function togglePlay(nodeId) {
            await ensureAudioContext();

            let playerData = audioState.activePlayers[nodeId];
            if (!playerData) {
                await createPlayer(nodeId);
                playerData = audioState.activePlayers[nodeId];
            }

            if (playerData && playerData.player) {
                const player = playerData.player;

                if (player.state === 'started') {
                    player.stop();
                    playerData.startTime = null;
                    highlightPlayingNode(nodeId, false);
                } else {
                    player.start();
                    playerData.startTime = Tone.now();
                    highlightPlayingNode(nodeId, true);
                }

                renderAudioPanel();
            }
        }

        function stopPlayer(nodeId) {
            const playerData = audioState.activePlayers[nodeId];
            if (playerData && playerData.player) {
                playerData.player.stop();
                playerData.startTime = null;
                highlightPlayingNode(nodeId, false);
                renderAudioPanel();
            }
        }

        function toggleLoop(nodeId) {
            const playerData = audioState.activePlayers[nodeId];
            if (playerData && playerData.player) {
                playerData.isLooping = !playerData.isLooping;
                playerData.player.loop = playerData.isLooping;
                renderAudioPanel();
            }
        }

        function setVolume(nodeId, volume) {
            const playerData = audioState.activePlayers[nodeId];
            if (playerData && playerData.player) {
                playerData.volume = volume;
                playerData.player.volume.value = Tone.gainToDb(volume);
                renderAudioPanel();
            }
        }

        function seekTo(nodeId, position) {
            const playerData = audioState.activePlayers[nodeId];
            if (playerData && playerData.player && playerData.duration > 0) {
                const wasPlaying = playerData.player.state === 'started';
                playerData.player.stop();
                playerData.player.start('+0', position);
                playerData.startTime = Tone.now() - position;
                if (!wasPlaying) {
                    playerData.player.stop();
                    playerData.startTime = null;
                }
                renderAudioPanel();
            }
        }

        function toggleExpand(nodeId) {
            const playerData = audioState.activePlayers[nodeId];
            if (playerData) {
                playerData.isExpanded = !playerData.isExpanded;
                renderAudioPanel();
            }
        }

        function stopAll() {
            Object.entries(audioState.activePlayers).forEach(([nodeId, playerData]) => {
                playerData.player.stop();
                playerData.startTime = null;
                highlightPlayingNode(nodeId, false);
            });
            renderAudioPanel();
        }

        async function playAll() {
            await ensureAudioContext();
            Object.entries(audioState.activePlayers).forEach(([nodeId, playerData]) => {
                if (playerData.player.state !== 'started') {
                    playerData.player.start();
                    playerData.startTime = Tone.now();
                    highlightPlayingNode(nodeId, true);
                }
            });
            renderAudioPanel();
        }

        function pauseAll() {
            Object.entries(audioState.activePlayers).forEach(([nodeId, playerData]) => {
                if (playerData.player.state === 'started') {
                    playerData.player.stop();
                    playerData.startTime = null;
                    highlightPlayingNode(nodeId, false);
                }
            });
            renderAudioPanel();
        }

        function clearAll() {
            Object.entries(audioState.activePlayers).forEach(([nodeId, playerData]) => {
                playerData.player.stop();
                playerData.player.dispose();
                highlightPlayingNode(nodeId, false);
            });
            audioState.activePlayers = {};
            audioState.singlePlayerNode = null;
            audioState.mixMode = false;
            renderAudioPanel();
        }

        // --- Rendering ---

        function renderAudioPanel() {
            if (audioState.mixMode) {
                renderMixMode();
            } else if (audioState.singlePlayerNode) {
                renderSinglePlayer();
            } else {
                panelContent.innerHTML = '<div style="padding: 20px; text-align: center; color: #888;">Click a node to play</div>';
            }
        }

        function renderSinglePlayer() {
            const node = getNodeData(audioState.singlePlayerNode);
            if (!node) return;

            const playerData = audioState.activePlayers[node.id];
            const player = playerData?.player;
            const isPlaying = player && player.state === 'started';
            const duration = playerData?.duration || 0;

            // Calculate current position
            let seek = 0;
            if (playerData?.startTime && isPlaying) {
                seek = Math.min(Tone.now() - playerData.startTime, duration);
            }
            const progress = duration > 0 ? Math.min((seek / duration) * 100, 100) : 0;

            panelContent.innerHTML = `
                <div class="single-player">
                    <div class="sp-header">
                        <div class="sp-title">${escapeHtml(node.name || 'Unknown Sample')}</div>
                        <div class="sp-meta">
                            ${node.user ? `<span>‚â°∆í√¶√± ${escapeHtml(node.user)}</span>` : ''}
                            ${node.duration ? `<span>Œì√Ö‚ñí ${node.duration.toFixed(1)}s</span>` : ''}
                        </div>
                    </div>
                    <div class="sp-controls">
                        <button class="btn-control ${isPlaying ? 'active' : ''}" onclick="window.audioPanel.togglePlay('${node.id}')">
                            ${isPlaying ? 'Œì√Ö‚ïï' : 'Œì√ª‚ï¢'}
                        </button>
                        <div class="sp-timeline-wrapper">
                            <div class="sp-timeline" onclick="window.audioPanel.handleTimelineClick(event, '${node.id}')">
                                <div class="sp-progress" style="width: ${progress}%"></div>
                            </div>
                            <div class="sp-time">${formatTime(seek)} / ${formatTime(duration)}</div>
                        </div>
                        <button class="btn-control" onclick="window.audioPanel.addToMix('${node.id}')" title="Add to Mix">
                            Œì‚Çß√≤
                        </button>
                    </div>
                </div>
            `;
        }

        function renderMixMode() {
            const playerIds = Object.keys(audioState.activePlayers);

            let listHtml = playerIds.map(id => {
                const node = getNodeData(id);
                const playerData = audioState.activePlayers[id];
                const player = playerData?.player;
                const isPlaying = player && player.state === 'started';
                const isExpanded = playerData?.isExpanded || false;
                const duration = playerData?.duration || 0;
                const volume = playerData?.volume || 0.8;
                const isLooping = playerData?.isLooping || false;

                // Calculate current position
                let seek = 0;
                if (playerData?.startTime && isPlaying) {
                    seek = Math.min(Tone.now() - playerData.startTime, duration);
                }
                const progress = duration > 0 ? Math.min((seek / duration) * 100, 100) : 0;

                if (isExpanded) {
                    return `
                        <div class="mix-item expanded">
                            <div class="mix-header-row" onclick="window.audioPanel.toggleExpand('${id}')">
                                <span class="expand-icon">Œì√ª‚ïù</span>
                                <div class="mix-name">${escapeHtml(node ? node.name : 'Unknown')}</div>
                                <button class="btn-mini btn-danger" onclick="event.stopPropagation(); window.audioPanel.removeFromMix('${id}')">Œì¬£√ª</button>
                            </div>
                            <div class="mix-expanded-content">
                                <div class="mix-timeline" onclick="window.audioPanel.handleTimelineClick(event, '${id}')">
                                    <div class="mix-progress" style="width: ${progress}%"></div>
                                </div>
                                <div class="mix-time">${formatTime(seek)} / ${formatTime(duration)}</div>
                                <div class="mix-controls-row">
                                    <button class="btn-mini ${isPlaying ? 'active' : ''}" onclick="window.audioPanel.togglePlay('${id}')" title="Play/Pause">
                                        ${isPlaying ? 'Œì√Ö‚ïï' : 'Œì√ª‚ï¢'}
                                    </button>
                                    <button class="btn-mini" onclick="window.audioPanel.stopPlayer('${id}')" title="Stop">Œì√Ö‚ï£</button>
                                    <button class="btn-mini ${isLooping ? 'active' : ''}" onclick="window.audioPanel.toggleLoop('${id}')" title="Loop">
                                        Œì∆í‚ñì
                                    </button>
                                    <div class="volume-control">
                                        <span class="volume-icon">‚â°∆í√∂√®</span>
                                        <input type="range" min="0" max="100" value="${Math.round(volume * 100)}" 
                                               class="volume-slider" 
                                               oninput="window.audioPanel.setVolume('${id}', this.value / 100)">
                                        <span class="volume-percent">${Math.round(volume * 100)}%</span>
                                    </div>
                                </div>
                                <div class="mix-metadata">
                                    ${node?.user ? `<div class="meta-row"><span class="meta-label">User:</span> ${escapeHtml(node.user)}</div>` : ''}
                                    ${node?.duration ? `<div class="meta-row"><span class="meta-label">Duration:</span> ${node.duration.toFixed(1)}s</div>` : ''}
                                    ${node?.tags ? `<div class="meta-row"><span class="meta-label">Tags:</span> ${escapeHtml(node.tags)}</div>` : ''}
                                    ${node?.downloads !== undefined ? `<div class="meta-row"><span class="meta-label">Downloads:</span> ${node.downloads}</div>` : ''}
                                    ${node?.rating !== undefined ? `<div class="meta-row"><span class="meta-label">Rating:</span> ${node.rating.toFixed(1)}</div>` : ''}
                                    ${node?.degree !== undefined ? `<div class="meta-row"><span class="meta-label">Connections:</span> ${node.degree}</div>` : ''}
                                    ${node?.centrality !== undefined ? `<div class="meta-row"><span class="meta-label">Centrality:</span> ${node.centrality.toFixed(4)}</div>` : ''}
                                    ${node?.community !== undefined ? `<div class="meta-row"><span class="meta-label">Community:</span> ${node.community}</div>` : ''}
                                </div>
                            </div>
                        </div>
                    `;
                } else {
                    return `
                        <div class="mix-item collapsed">
                            <div class="mix-header-row" onclick="window.audioPanel.toggleExpand('${id}')">
                                <span class="expand-icon">Œì√ª‚ï¢</span>
                                <div class="mix-name">${escapeHtml(node ? node.name : 'Unknown')}</div>
                                <button class="btn-mini btn-danger" onclick="event.stopPropagation(); window.audioPanel.removeFromMix('${id}')">Œì¬£√ª</button>
                            </div>
                        </div>
                    `;
                }
            }).join('');

            panelContent.innerHTML = `
                <div class="mix-mode">
                    <div class="mix-header">
                        <div class="mix-title">‚â°∆í√Ñ‚ï° Audio Mix (${playerIds.length})</div>
                        <div class="mix-master-controls">
                            <button class="btn-mini" onclick="window.audioPanel.playAll()" title="Play All">Œì√ª‚ï¢ All</button>
                            <button class="btn-mini" onclick="window.audioPanel.pauseAll()" title="Pause All">Œì√Ö‚ïï All</button>
                            <button class="btn-mini" onclick="window.audioPanel.stopAll()" title="Stop All">Œì√Ö‚ï£ All</button>
                            <button class="btn-mini btn-danger" onclick="window.audioPanel.clearAll()" title="Clear All">Clear</button>
                        </div>
                    </div>
                    <div class="mix-bpm-control">
                        <label>BPM:</label>
                        <input type="number" min="60" max="200" value="${audioState.globalBPM}" 
                               onchange="window.audioPanel.setBPM(this.value)">
                    </div>
                    <div class="mix-list">
                        ${listHtml}
                    </div>
                </div>
            `;
        }

        function handleTimelineClick(event, nodeId) {
            const timeline = event.currentTarget;
            const rect = timeline.getBoundingClientRect();
            const clickX = event.clientX - rect.left;
            const percentage = clickX / rect.width;
            
            const playerData = audioState.activePlayers[nodeId];
            if (playerData && playerData.duration > 0) {
                const position = percentage * playerData.duration;
                seekTo(nodeId, position);
            }
        }

        function setBPM(bpm) {
            audioState.globalBPM = parseInt(bpm) || 120;
            renderAudioPanel();
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // --- Highlight Update ---
        function highlightPlayingNode(nodeId, isPlaying) {
            if (nodeId && graph.hasNode(nodeId)) {
                if (isPlaying) {
                    const node = graph.getNodeAttributes(nodeId);
                    if (!node.originalColor) {
                        graph.setNodeAttribute(nodeId, 'originalColor', node.color);
                    }
                    graph.setNodeAttribute(nodeId, 'color', '#FFD93D');
                } else {
                    const node = graph.getNodeAttributes(nodeId);
                    if (node.originalColor) {
                        graph.setNodeAttribute(nodeId, 'color', node.originalColor);
                    }
                }
                renderer.refresh();
            }
        }

        // --- Event Listeners ---

        // Update Node Click Handler
        renderer.on('clickNode', async ({ node }) => {
            await showSinglePlayer(node);
        });

        // Periodic update for timelines
        setInterval(() => {
            if (audioState.singlePlayerNode || audioState.mixMode) {
                renderAudioPanel();
            }
        }, 200);

        // --- Expose API to window ---
        window.audioPanel = {
            togglePlay,
            addToMix,
            removeFromMix,
            playAll,
            pauseAll,
            stopAll,
            clearAll,
            showSinglePlayer,
            stopPlayer,
            toggleLoop,
            setVolume,
            toggleExpand,
            handleTimelineClick,
            setBPM
        };

        // Initial render
        renderAudioPanel();

        console.log('Audio panel initialized with Tone.js');
    });
})();
    </script>
</body>

</html>